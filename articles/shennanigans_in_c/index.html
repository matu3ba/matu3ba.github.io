<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>matu3bas Website</title>
    <link rel="stylesheet" type="text/css" href="/normalize.css">
    <link rel="stylesheet" type="text/css" href="/style.css">
  </head>
  <body>
    <div class="home_page">
      <div class='static_grid'>
          <div class='static_double_column1'>
            <h1><span class="reset_a"><a href="/">Jans Website</a></span></h1>
          </div>
          <div class='static_double_column2'>
            <h2>C shennanigans: Pointers, sequence points and bit fields.</h2>
          </div>
          <div class='static_double_column3'>
            <div><div id=intro><p> This article focuses on some of the non-obvious and easy to make mistakes non-experienced C programmers are likely to make and are/can not completely be covered by tooling without going into edge cases relevant to performance and covering the most simple and conservative approach:</p><ul><li>1.<a href="#pointer_semantics">Pointer semantics</a></li><li>2.<a href="#seq_pts">Sequence points</a></li><li>3.<a href="#bitfields">Bit-fields</a></li></ul><p>Compiler flags or implementation may provide workarounds to these problems to prevent optimizations based on introduced Undefined Behavior (UB). Review used C compilers with flags used including tests and platforms before reusing of any code. The <a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152200" target="_blank">SEI wiki covers some basic cases</a> without covering compiler workarounds. Pointer construction is widely unspecified in earlier C standards before C11 and up to this day with C23 pointer semantics have no formal model, see also item <a href="#pointer_construction_requirements">pointer construction requirements</a>.</p></div></div>
            <ol>
              <li><a id ="pointer_semantics"><b>Pointer semantics</b> in C</a>.
                <ol>
                  <li><a href="#pointer_access_requirements">Pointer access requirements</a></li>
                  <li><a href="#pointer_access_practice">Pointer access in practice</a></li>
                  <li><a href="#pointer_exceptions">The Exceptions</a></li>
                  <li><a href="#pointer_construction_requirements">Pointer construction requirements</a></li>
                  <li><a href="#pointer_construction_practice">Pointer construction in practice</a></li>
                </ol>
                <ol>
                  <!--<li><div :html="$page.contentSection('pointer_access_requirements')"></div></li>-->
                  <li>
                    <a id="pointer_access_requirements"><b>Pointer access requirements</b></a> are fairly well specified from C89 on in
                    strong contrast to <a href="#pointer_construction_requirements">pointer construction requirements</a> and programmers with knowledge
                    of how processing hardware works can derive below information.
                    <ol>
                      <li> <span>Proper <b>alignment</b></span> </li>
                        <ul>
                          <li><span>Cleanly accessing a pointer with increased alignment requires to use a temporary with memcopy.</span>
                          </li>
                          <li>
                            <span>To only compare pointers decrease alignment with <code><span class="tok-type">char</span>*</code> pointer.</span>
                          </li>
                          <li> <span>To prune type info for generics use <code>void*</code> pointer.</span> </li>
                          <li> <span>You are responsible to call a function that provides or provide yourself.</span> </li>
                        </ul>
                      <li> <span>Sufficient <b>storage</b> (pointer must point to valid object)</span> </li>
                      <li> <span>Sufficient <b>padding</b> (ie within structs).</span> </li>
                      <li>
                        <span>Correct <b>aliasing</b> (<a id="strict_aliasing_rule"><b>"Strict Aliasing Rule"</b></a>)</span>
                        <div><div id=strict_aliasing_rule:expl><ul><li>C23 6.5 Expressions paragraph 7<br>“An object shall have its stored value accessed only by an lvalue expression that has one of the following types<ul><li>a type compatible with the effective type of the object,</li><li>a qualified version of a type compatible with the effective type of the object,</li><li>a type that is the signed or unsigned type corresponding to the effective type of the object,</li><li>a type that is the signed or unsigned type corresponding to a qualified version of the effective type of the object,</li><li>an aggregate or union type that includes one of the aforementioned types among its members (including, recursively, a member of a subaggregate or contained union), or</li><li>a character type.”</li></ul></li><li>What does this means in <strong>practice</strong>?<br>Each pointer has an associated “provenance” it is allowed to point to. This mean that a pointer <code>ptr</code> must uphold <code>(&amp;amp;array[0] &lt;= ptr &amp;amp;&amp;amp; ptr &lt; &amp;amp;array[len+1])</code> for access with array being the “memory origin range” on stack or heap. Pointers must point to the same array, when being used for arithmetic.<br>Function arguments of identical pointer types are allowed to have overlapping provenance regions, unless annotated with <code>restrict</code> (<code>__restrict__</code> for C++ in clang/gcc), but pointers of different types are not allowed to have those regions. Pointer comparison must be done via identical alignments, unless comparison of a pointer against pointer to 0, usually abbreviated via macro <code>NULL</code>.</li></ul></div></div>
                      </li>
                    </ol>
                  </li>
                  <li><div><div id=pointer_access_practice><p> <strong>Pointer access</strong> in <strong>practice</strong>.</p><ul><li>Provenance as regions pointer is allowed to point to for access. <figure><pre><code class="c"><span class="keyword">#include</span> <span class="string">&lt;stdio.h&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;stdlib.h&gt;</span>
<span class="type">void</span> <span class="function">use_ptr</span>(<span class="type">int</span> <span class="operator">*</span><span class="variable">arr</span>) { <span class="function">printf</span>(<span class="string">&quot;0: %d, 9: %d\n&quot;</span>, <span class="variable">arr</span>[<span class="number">0</span>], <span class="variable">arr</span>[<span class="number">9</span>])<span class="delimiter">;</span> }
<span class="type">int</span> <span class="function">main</span>() {
  <span class="type">int</span> <span class="variable">arr1</span>[<span class="number">10</span>]<span class="delimiter">;</span>
  <span class="function">use_ptr</span>(<span class="variable">arr1</span>)<span class="delimiter">;</span>
  <span class="type">int</span> <span class="operator">*</span><span class="variable">arr2</span> <span class="operator">=</span> <span class="function">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>))<span class="delimiter">;</span>
  <span class="function">use_ptr</span>(<span class="variable">arr2</span>)<span class="delimiter">;</span>
  <span class="function">free</span>(<span class="variable">arr2</span>)<span class="delimiter">;</span>
}
</code></pre>
<figcaption>provenance.c</figcaption></figure></li><li>Copy around some bytes from not overlapping regions (otherwise use memmove). <figure><pre><code class="c"><span class="keyword">#include</span> <span class="string">&lt;stdint.h&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;string.h&gt;</span>
<span class="type">void</span> <span class="function">use_bytes</span>(<span class="type">uint8_t</span> <span class="operator">*</span><span class="variable">bytes</span>, <span class="type">int32_t</span> <span class="variable">len_bytes</span>, <span class="type">uint32_t</span> <span class="operator">*</span><span class="variable">output</span>, <span class="type">int32_t</span> <span class="variable">len_output</span>) {
  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span><span class="delimiter">;</span> <span class="variable">i</span> <span class="operator">*</span> <span class="number">4</span> <span class="operator">&lt;</span> <span class="variable">len_bytes</span> <span class="operator">&amp;&amp;</span> <span class="variable">i</span> <span class="operator">&lt;</span> <span class="variable">len_output</span><span class="delimiter">;</span> <span class="variable">i</span> <span class="operator">+=</span> <span class="number">4</span>) {
    <span class="function">memcpy</span>(<span class="operator">&amp;</span><span class="variable">output</span>[<span class="variable">i</span>], <span class="operator">&amp;</span><span class="variable">bytes</span>[<span class="number">4</span> <span class="operator">*</span> <span class="variable">i</span>], <span class="keyword">sizeof</span>(<span class="variable">len_output</span>))<span class="delimiter">;</span>
  }
}
</code></pre>
<figcaption>copy_bytes.c</figcaption></figure></li><li>Correct alignment of pointers with temporary, when necessary. <figure><pre><code class="c"><span class="keyword">#include</span> <span class="string">&lt;stdint.h&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;string.h&gt;</span>
<span class="type">int</span> <span class="function">ptr_no_reinterpret_cast</span>() {
  <span class="type">uint8_t</span> <span class="variable">arr</span>[<span class="number">4</span>] <span class="operator">=</span> {<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>}<span class="delimiter">;</span>
  <span class="comment">// unnecessary variable hopefully elided</span>
  <span class="type">uint32_t</span> <span class="variable">u32_arr</span> <span class="operator">=</span> <span class="number">0</span><span class="delimiter">;</span>
  <span class="function">memcpy</span>(<span class="operator">&amp;</span><span class="variable">u32_arr</span>, <span class="operator">&amp;</span><span class="variable">arr</span>[<span class="number">0</span>], <span class="number">4</span>)<span class="delimiter">;</span>
  <span class="type">uint32_t</span> <span class="operator">*</span><span class="variable">u32_arr_ptr</span> <span class="operator">=</span> <span class="operator">&amp;</span><span class="variable">u32_arr</span><span class="delimiter">;</span>
  <span class="comment">// &lt;use u32_arr_ptr here&gt;</span>
  <span class="comment">// Footgun: Dont return stack local variables</span>
  (<span class="type">void</span>)<span class="variable">u32_arr_ptr</span><span class="delimiter">;</span>
  <span class="keyword">return</span> <span class="number">0</span><span class="delimiter">;</span>
}
</code></pre>
<figcaption>correct_alignment.c</figcaption></figure></li><li>Ensure correct storage and padding size for pointers via sizeof. <figure><pre><code class="c"><span class="keyword">#include</span> <span class="string">&lt;stdint.h&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;stdlib.h&gt;</span>
<span class="keyword">struct</span> <span class="type">sStruct1</span> {
  <span class="type">uint8_t</span> <span class="property">a1</span><span class="delimiter">;</span>
  <span class="type">uint8_t</span> <span class="property">a2</span><span class="delimiter">;</span>
  <span class="type">uint32_t</span> <span class="property">b1</span><span class="delimiter">;</span>
  <span class="type">uint32_t</span> <span class="property">b2</span><span class="delimiter">;</span>
}<span class="delimiter">;</span>
<span class="type">void</span> <span class="function">padding</span>() {
  <span class="keyword">struct</span> <span class="type">sStruct1</span> <span class="operator">*</span><span class="variable">str1</span> <span class="operator">=</span> <span class="function">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="type">sStruct1</span>))<span class="delimiter">;</span>
  <span class="variable">str1</span><span class="operator">-&gt;</span><span class="property">a1</span> <span class="operator">=</span> <span class="number">5</span><span class="delimiter">;</span>
  <span class="function">free</span>(<span class="variable">str1</span>)<span class="delimiter">;</span>
}
</code></pre>
<figcaption>storage_padding.c</figcaption></figure></li><li>Allowed aliasing of pointers (type-based aliasing analysis) <figure><pre><code class="c"><span class="keyword">#include</span> <span class="string">&lt;stdint.h&gt;</span>
<span class="type">void</span> <span class="function">allowed_aliasing</span>(<span class="type">uint16_t</span> <span class="operator">*</span><span class="variable">bytes</span>, <span class="type">int32_t</span> <span class="variable">len_bytes</span>, <span class="type">uint16_t</span> <span class="operator">*</span><span class="variable">lim</span>) {
  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span><span class="delimiter">;</span> <span class="variable">i</span> <span class="operator">&lt;</span> <span class="variable">len_bytes</span><span class="delimiter">;</span> <span class="variable">i</span> <span class="operator">+=</span> <span class="number">1</span>) {
    <span class="keyword">if</span> (<span class="variable">bytes</span> <span class="operator">==</span> <span class="variable">lim</span>)
      <span class="keyword">break</span><span class="delimiter">;</span>
    <span class="variable">bytes</span>[<span class="variable">i</span>] <span class="operator">=</span> <span class="number">42</span><span class="delimiter">;</span>
  }
}
</code></pre>
<figcaption>allowed_aliasing.c</figcaption></figure></li><li>Non-allowed aliasing of pointers (type-based aliasing analysis) <figure><pre><code class="c"><span class="keyword">#include</span> <span class="string">&lt;stdint.h&gt;</span>
<span class="type">void</span> <span class="function">non_allowed_aliasing</span>(<span class="type">uint16_t</span> <span class="operator">*</span><span class="variable">bytes</span>, <span class="type">int32_t</span> <span class="variable">len_bytes</span>, <span class="type">uint8_t</span> <span class="operator">*</span><span class="variable">lim</span>) {
  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span><span class="delimiter">;</span> <span class="variable">i</span> <span class="operator">&lt;</span> <span class="variable">len_bytes</span><span class="delimiter">;</span> <span class="variable">i</span> <span class="operator">+=</span> <span class="number">1</span>) {
    <span class="keyword">if</span> (<span class="variable">bytes</span> <span class="operator">==</span> <span class="variable">lim</span>)
      <span class="keyword">break</span><span class="delimiter">;</span>
    <span class="variable">bytes</span>[<span class="variable">i</span>] <span class="operator">=</span> <span class="number">42</span><span class="delimiter">;</span>
  }
}
</code></pre>
<figcaption>non_allowed_aliasing.c</figcaption></figure></li></ul></div></div></li>
                  <li><div><div id=pointer_exceptions><p> <strong>The Exceptions</strong></p><ul><li>Controlling the build system and compiler invocation to opt-out of provenance based optimizations.<ol><li>Clang and gcc have <code>-fno-strict-aliasing</code>, msvc and tcc do disable type-based aliasing analysis based optimizations.</li><li>As of 20240603, there is no switch to disable provenance-based alias analysis in compilers (clang, gcc, msvc, tcc).</li><li>Usage of <code>restrict</code> can be en/disabled in all compilers via <code>#pragma optimize(&quot;&quot;, on/off)</code>. It can also be disabled in all compilers via <code>#define restrict</code>, using an according optimization level (typical <code>-O1</code>) or via separating header and implementation and disabling link time optimziations.</li></ol></li><li>Posix extension and Windows in practice enable dynamic linking via casting pointers <code>void *</code> to function pointers and back. This also means that <code>sizeof (function pointer) == sizeof (void *)</code> must be uphold, which is not true for microcontrollers with separate address space for code and data or CHERI in mixed capability mode/hybrid compilation mode. Address space annotations are mandatory for this to work and it is unfortunate that standards do not reflect this as of 20240428. <figure><pre><code class="c"><span class="keyword">#include</span> <span class="string">&lt;assert.h&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;stdint.h&gt;</span>
<span class="type">uint8_t</span> <span class="variable">external_memory</span>[<span class="number">1024</span>]<span class="delimiter">;</span>
<span class="keyword">typedef</span> <span class="type">int</span> (<span class="operator">*</span><span class="type">pfn_add_one</span>)(<span class="type">int</span>)<span class="delimiter">;</span>
<span class="type">int</span> <span class="function">add_one</span>(<span class="type">int</span> <span class="variable">x</span>) { <span class="keyword">return</span> <span class="variable">x</span> <span class="operator">+</span> <span class="number">1</span><span class="delimiter">;</span> }
<span class="type">void</span> <span class="function">usage</span>(<span class="type">int</span> <span class="variable">x</span>) {
  <span class="comment">// read fn ptr from external code</span>
  <span class="type">void</span> <span class="operator">*</span><span class="variable">pv_add_one</span> <span class="operator">=</span> (<span class="type">void</span> <span class="operator">*</span>)<span class="variable">external_memory</span><span class="delimiter">;</span>
  <span class="type">pfn_add_one</span> <span class="variable">pfn_add_one_casted</span> <span class="operator">=</span> (<span class="type">pfn_add_one</span>)<span class="variable">pv_add_one</span><span class="delimiter">;</span>
  <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="function">pfn_add_one_casted</span>(<span class="number">1</span>)<span class="delimiter">;</span>
  <span class="function">assert</span>(<span class="variable">res</span> <span class="operator">==</span> <span class="number">2</span>)<span class="delimiter">;</span>
}
</code></pre>
<figcaption>aliasing_exceptions_uniform_address_space.c</figcaption></figure></li></ul></div></div></li>
                  <li><div><div id=pointer_construction_requirements><p> <strong>Pointer construction requirements</strong> are unspecified in all C standards with potentially some hints and nothing concrete up to including C23 which further implies that pointer semantics have no formal model. At least a few possible formal models exist (paper VIP: Verifying Real-World C Idioms with Integer-Pointer Casts, N2676, P2318R1: A Provenance-aware Memory Object Model for C) so far without taking into account CHERI in mixed capability mode/hybrid compilation mode and from what I understand without taking all equivalence classes of pointer operations into account.<br>Therefore it is best to use the most conservative approach xor to provide the set of chosen (non-portable) compiler semantics in the build system next to the code to remove room for ambiguity.<br>For further information about this, take a look into paper “Subtleties of the ANSI/ISO C standard” and “n2263: Clarifying Pointer Provenance v4”.<br>To simplify things, we can however extend the strict aliasing rule pointer construction with shortcomings regarding “effective type” on type punning for hardware related programming: This would mean that generated pointers must uphold <code>(&amp;array[0] &lt;= ptr &amp;&amp; ptr &lt;= &amp;array[len+1]) || ptr == 0 || ptr = undefined)</code> with <code>ptr == 0</code> and undefined pointers being the exceptions.<br>Standards up to including C23 do not specify this behavior explicitly. For example C23 specifies that operations on pointers to a object must remain in the above given range and temporal pointer overflow behavior is undefined. Expected behavior of exposed (externally readable and writable) addresses via headers and object files including possible future C standard direction can be found in “A Provenance-aware Memory Object Model for C”.<br>Temporal out of bounds behavior, linker semantics with guaranteed addresses or address regions and all other constrains remain unspecified.<br>It is not discussed here how the optimizer would prove how serialized and deserialized pointer have the same provenance regions (integer cast, memory copy or external usage), because there are multiple algorithms and this article is already too long.<br>Rust decided to allow programmers experimental low level control over provenance with experimenting on CHERI and an interpreter for iterating on the provenance model and to work(around) with backends, see Rust RFC 3559 title “rust_has_provenance” and section “Drawbacks”.<br>The following special cases of pointer operations can be taken into account, when discussing provenance-based optimizations (in contrast to type-based aliasing analysis):</p><ul><li>1.<a href="#opaque">Opaque type idiom.</a><br>Opaque types provide a way to guarantee correct usage of object and pointer properties for a library or API user and thus should be preferred, if feasible.</li><li>2.<a href="#ptrintconv">Pointer to integer and integer to pointer conversion.</a><br>Pointer/integer to integer/pointer conversion mandates in all suggested models for pointer semantics (of C) to prevent provenance-based optimizations unless the optimizer can prove with certainty the origin of pointer provenance and/or programmers must/can annotate provenance information to pointers to guide the optimizer about which memory relations can and can not be optimized (unstandardised).</li><li>3.Headers/exports exposing data structures, pointers to data structures and void pointers.<br><a href="#lto">Link time optimization (LTO)</a> works across across header and object boundaries if sufficient information/artefacts for caller and callee are given, so construction of exposed aliasing pointers may lead to undefined behavior depending on the build system flags and used compiler.</li><li>4.Compiler intrinsics for IO: memcmp, memcpy, memmove, memset.<br><a href="#io_intrinsics">IO Compiler intrinsic semantics</a> are yet to be taken portably into account due to a lot legacy code relying on certain properties and pointer properties like alignment being implicit. Technically optimizations are possible with annotating sufficient pointer information and useful to accelerate via SIMD and tracking provenance along pointers, like for different addressing modes or capabilities in CHERI, would be further useful.</li><li>5.Checking C code validity with Cerberus.<br><a href="#cerberus">Cerberus</a> allows checking C code semantics for most common idioms, but does not support the complete corpus of C syntax. It also offers checking semantics of multithreaded code, but this is out of scope for this article.</li><li>6.CHERI rules for pointers.<br>In <a href="#cheri">CHERI</a> mixed-capability mode pointers may be raw pointers inclusive or pointer with annotated capabilities, which can include things like lower and upper address bound, permissions masks, flags usable for OS or application tasks, see “Capability Hardware Enhanced RISC Instructions: CHERI Instruction-Set Architecture (Version 9)”. Since there is no formal model on how CHERI pointer semantics work, examples are not included. A work in progress CHERI C is given in paper “Formal Mechanised Semantics of CHERI C: Capabilities, Undefined Behaviour, and Provenance”. CHERI offers (scalable) compartmentalization, spatial memory safety with opt-in temporal memory safety via runtime support mandating pointer capability revocation on freeing memory with latest example being CheriBSD experimental userspace temporal memory safety (20240602).</li><li>7.What to expect for the future.<br>LLVM support for full restrict has been merged, but <a href="https://www.reddit.com/r/rust/comments/1ft619r/llvm_rfc_improvements_to_capture_tracking/" target="_blank">it has design and quality problems</a>, so it looks like the C++ code base of LLVM prevents faster iterations and/or more fundamental changes, since the feature is in development for now ca. 5 years (since 2019). Semantic implications are not communicated and neither formalized, so the future path remains unclear. This is reflected by <a href="https://github.com/rust-lang/rust/issues/107975" target="_blank">long-lasting miscompilations not getting fixed</a>.</li></ul></div></div></li>
                  <li>
                    <div><div id=pointer_construction_practice><p> <strong>Pointer construction in practice.</strong> The original intention was to explain provenance based rules, but due to long standing bugs in LLVM and gcc and no formal model with performance safety, compilation time and other implications, I would suggest the reader to write thorough tests and on doubts about testability to disable provenance based optimizations, especially in production code.<br>Optimizers with provenance based optimization steps are unfortunately not build with controllability and debuggability in mind and standard bodies so far can not recommend any extensive test corpus to derive how frontend and backend optimizer tests would need to be designed.<br>Other more elaborative examples can be seen in the github gist “What is the Strict Aliasing Rule and Why do we care?”.</p></div></div>
                    <ol>
                      <li><div><div id=opaque><p> Opaque type idiom. <figure><pre><code class="c"><span class="keyword">#include</span> <span class="string">&lt;stddef.h&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;stdint.h&gt;</span>
<span class="keyword">struct</span> <span class="type">item</span><span class="delimiter">;</span>
<span class="type">size_t</span> <span class="function">item_size</span>(<span class="type">void</span>)<span class="delimiter">;</span>
<span class="type">void</span> <span class="function">id_setid</span>(<span class="keyword">struct</span> <span class="type">item</span> <span class="operator">*</span><span class="variable">it</span>, <span class="type">int32_t</span> <span class="variable">id</span>)<span class="delimiter">;</span>
<span class="type">int</span> <span class="function">item_getid</span>(<span class="keyword">struct</span> <span class="type">item</span> <span class="operator">*</span><span class="variable">it</span>)<span class="delimiter">;</span>
</code></pre>
<figcaption>opaque.h</figcaption></figure> <figure><pre><code class="c"><span class="keyword">#include</span> <span class="string">&quot;opaque.h&quot;</span>
<span class="keyword">struct</span> <span class="type">item</span> {
  <span class="type">int32_t</span> <span class="property">id</span><span class="delimiter">;</span>
}<span class="delimiter">;</span>
<span class="type">size_t</span> <span class="function">item_size</span>(<span class="type">void</span>) { <span class="keyword">return</span> <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="type">item</span>)<span class="delimiter">;</span> }
<span class="type">void</span> <span class="function">id_setid</span>(<span class="keyword">struct</span> <span class="type">item</span> <span class="operator">*</span><span class="variable">it</span>, <span class="type">int32_t</span> <span class="variable">id</span>) { <span class="variable">it</span><span class="operator">-&gt;</span><span class="property">id</span> <span class="operator">=</span> <span class="variable">id</span><span class="delimiter">;</span> }
<span class="type">int</span> <span class="function">item_getid</span>(<span class="keyword">struct</span> <span class="type">item</span> <span class="operator">*</span><span class="variable">it</span>) { <span class="keyword">return</span> <span class="variable">it</span><span class="operator">-&gt;</span><span class="property">id</span><span class="delimiter">;</span> }
</code></pre>
<figcaption>opaque.c</figcaption></figure></p></div></div></li>
                      <li><div><div id=ptrintconv><p> Pointer to integer and integer to pointer conversion. <figure><pre><code class="c"><span class="keyword">#include</span> <span class="string">&lt;assert.h&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;inttypes.h&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;stdio.h&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;stdlib.h&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;string.h&gt;</span>
<span class="keyword">static</span> <span class="type">void</span> <span class="function">memset_16aligned</span>(<span class="type">void</span> <span class="operator">*</span><span class="variable">ptr</span>, <span class="type">char</span> <span class="variable">byte</span>, <span class="type">size_t</span> <span class="variable">size_bytes</span>, <span class="type">uint16_t</span> <span class="variable">alignment</span>) {
  <span class="function">assert</span>((<span class="variable">size_bytes</span> <span class="operator">&amp;</span> (<span class="variable">alignment</span> <span class="operator">-</span> <span class="number">1</span>)) <span class="operator">==</span> <span class="number">0</span>)<span class="delimiter">;</span>     <span class="comment">// Size aligned</span>
  <span class="function">assert</span>(((<span class="type">uintptr_t</span>)<span class="variable">ptr</span> <span class="operator">&amp;</span> (<span class="variable">alignment</span> <span class="operator">-</span> <span class="number">1</span>)) <span class="operator">==</span> <span class="number">0</span>)<span class="delimiter">;</span> <span class="comment">// Pointer aligned</span>
  <span class="function">memset</span>(<span class="variable">ptr</span>, <span class="variable">byte</span>, <span class="variable">size_bytes</span>)<span class="delimiter">;</span>
}
<span class="comment">// 1. Careful with segmented address spaces: lookup uintptr_t semantics</span>
<span class="comment">// 2. Careful with long standing existing optimization compiler bugs pointer to</span>
<span class="comment">// integer and back optimizations in for example clang and gcc</span>
<span class="comment">// 3. Careful with LTO potentially creating problem 2.</span>
<span class="comment">// 4. Consider C11 aligned_alloc or posix_memalign</span>
<span class="type">void</span> <span class="function">ptrtointtoptr</span>() {
  <span class="type">uint16_t</span> <span class="keyword">const</span> <span class="variable">alignment</span> <span class="operator">=</span> <span class="number">16</span><span class="delimiter">;</span>
  <span class="type">uint16_t</span> <span class="keyword">const</span> <span class="variable">align_min_1</span> <span class="operator">=</span> <span class="variable">alignment</span> <span class="operator">-</span> <span class="number">1</span><span class="delimiter">;</span>
  <span class="type">void</span> <span class="operator">*</span><span class="variable">mem</span> <span class="operator">=</span> <span class="function">malloc</span>(<span class="number">1024</span> <span class="operator">+</span> <span class="variable">align_min_1</span>)<span class="delimiter">;</span>
  <span class="comment">// C89: void *ptr = (void *)(((INT_WITH_PTR_SIZE)mem+align_min_1) &amp; ~(INT_WITH_PTR_SIZE)align_min_1);</span>
  <span class="comment">// ie void *ptr = (void *)(((uint64_t)mem+align_min_1) &amp; ~(uint64_t)align_min_1);</span>
  <span class="comment">// offset ptr to next alignment byte boundary</span>
  <span class="type">void</span> <span class="operator">*</span><span class="variable">ptr</span> <span class="operator">=</span> (<span class="type">void</span> <span class="operator">*</span>)(((<span class="type">uintptr_t</span>)<span class="variable">mem</span> <span class="operator">+</span> <span class="variable">align_min_1</span>) <span class="operator">&amp;</span> ~(<span class="type">uintptr_t</span>)<span class="variable">align_min_1</span>)<span class="delimiter">;</span>
  <span class="function">printf</span>(<span class="string">&quot;0x%08&quot;</span> <span class="variable">PRIXPTR</span> <span class="string">&quot;, 0x%08&quot;</span> <span class="variable">PRIXPTR</span> <span class="string">&quot;\n&quot;</span>, (<span class="type">uintptr_t</span>)<span class="variable">mem</span>, (<span class="type">uintptr_t</span>)<span class="variable">ptr</span>)<span class="delimiter">;</span>
  <span class="function">memset_16aligned</span>(<span class="variable">ptr</span>, <span class="number">0</span>, <span class="number">1024</span>, <span class="variable">alignment</span>)<span class="delimiter">;</span>
  <span class="function">free</span>(<span class="variable">mem</span>)<span class="delimiter">;</span>
}
</code></pre>
<figcaption>ptrtoint_inttoptr.c</figcaption></figure></p></div></div></li>
                      <li><div><div id=lto><p> Link time optimization (LTO) usage and problems. One can use <code>ptrtoint_inttoptr.c</code> with flags for strong LTO to optimize the bit code of the complete program, for example via <code>clang -flto -funified-lto -fuse-ld=lld ptrtoint_inttoptr.c</code>.</p></div></div></li>
                      <li><div><div id=io_intrinsics><p> IO Compiler intrinsic semantics example. It would be helpful to have a way to add alignment to pointers to have th compiler automatically do runtime selection of the best SIMD routine instead of being forced to do this manually. <code>__attribute__(aligned(ALIGNMENT)</code>, <code>_Alignas(ALIGNMENT)</code>, <code>alignas(ALIGNMENT)</code> do offer no guarantee that the code is vectorized and one has to check for example via <code>clang -O3 -Rpass=loop-vectorize -Rpass-missed=loop-vectorize -Rpass-analysis=loop-vectorize</code> or <code>gcc -O3 -ftree-vectorizer-verbose=3</code> and use <a href="https://clang.llvm.org/docs/LanguageExtensions.html" target="_blank">clang extensions</a> and <a href="https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html" target="_blank">gcc extensions</a> like <code>__builtin_assume_aligned</code>. <figure><pre><code class="c"><span class="keyword">#include</span> <span class="string">&lt;immintrin.h&gt;</span>
<span class="type">void</span> <span class="function">memcpy_avx</span>(<span class="type">__m256i</span> <span class="operator">*</span>__restrict <span class="variable">src</span>, <span class="type">__m256i</span> <span class="operator">*</span>__restrict <span class="variable">dest</span>, <span class="type">size_t</span> <span class="variable">n</span>)<span class="delimiter">;</span>
</code></pre>
<figcaption>extern_avx.h</figcaption></figure> <figure><pre><code class="c"><span class="keyword">#include</span> <span class="string">&quot;extern_avx.h&quot;</span>
<span class="comment">/// requires 32 byte aligned src, dest; src and dest must not overlap</span>
<span class="type">void</span> <span class="function">memcpy_avx</span>(<span class="type">__m256i</span> <span class="operator">*</span>__restrict <span class="variable">src</span>, <span class="type">__m256i</span> <span class="operator">*</span>__restrict <span class="variable">dest</span>, <span class="type">size_t</span> <span class="variable">n</span>) {
  <span class="type">size_t</span> <span class="variable">n_vec</span> <span class="operator">=</span> <span class="variable">n</span> / <span class="keyword">sizeof</span>(<span class="variable">__m256i</span>)<span class="delimiter">;</span>
  <span class="keyword">for</span> (<span class="type">size_t</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span><span class="delimiter">;</span> <span class="variable">i</span> <span class="operator">&lt;</span> <span class="variable">n_vec</span><span class="delimiter">;</span> <span class="variable">i</span> <span class="operator">+=</span> <span class="number">1</span>) {
    <span class="type">__m256i</span> <span class="keyword">const</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="function">_mm256_load_si256</span>(<span class="variable">src</span>)<span class="delimiter">;</span>
    <span class="function">_mm256_store_si256</span>(<span class="variable">dest</span>, <span class="variable">temp</span>)<span class="delimiter">;</span>
    <span class="variable">src</span> <span class="operator">+=</span> <span class="number">1</span><span class="delimiter">;</span>
    <span class="variable">dest</span> <span class="operator">+=</span> <span class="number">1</span><span class="delimiter">;</span>
  }
}
</code></pre>
<figcaption>extern_avx.c</figcaption></figure> <figure><pre><code class="c"><span class="keyword">#include</span> <span class="string">&lt;stdint.h&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;stdio.h&gt;</span>

<span class="keyword">#include</span> <span class="string">&quot;extern_avx.h&quot;</span>
<span class="type">int</span> <span class="function">main</span>(<span class="type">void</span>) {
  <span class="type">uint8_t</span> <span class="variable">mem_src</span>[<span class="number">1024</span>] <span class="operator">=</span> {<span class="number">0</span>}<span class="delimiter">;</span>
  <span class="type">uint8_t</span> <span class="variable">mem_dest</span>[<span class="number">1024</span>] <span class="operator">=</span> {<span class="number">0</span>}<span class="delimiter">;</span>
  <span class="type">uint16_t</span> <span class="keyword">const</span> <span class="variable">alignment</span> <span class="operator">=</span> <span class="number">32</span><span class="delimiter">;</span>
  <span class="type">uint16_t</span> <span class="keyword">const</span> <span class="variable">align_min_1</span> <span class="operator">=</span> <span class="variable">alignment</span> <span class="operator">-</span> <span class="number">1</span><span class="delimiter">;</span>
  <span class="type">__m256i</span> <span class="operator">*</span><span class="variable">p_src</span> <span class="operator">=</span> (<span class="type">void</span> <span class="operator">*</span>)(((<span class="type">uintptr_t</span>)<span class="variable">mem_src</span> <span class="operator">+</span> <span class="variable">align_min_1</span>) <span class="operator">&amp;</span> ~(<span class="type">uintptr_t</span>)<span class="variable">align_min_1</span>)<span class="delimiter">;</span>
  <span class="type">__m256i</span> <span class="operator">*</span><span class="variable">p_dest</span> <span class="operator">=</span> (<span class="type">void</span> <span class="operator">*</span>)(((<span class="type">uintptr_t</span>)<span class="variable">mem_dest</span> <span class="operator">+</span> <span class="variable">align_min_1</span>) <span class="operator">&amp;</span> ~(<span class="type">uintptr_t</span>)<span class="variable">align_min_1</span>)<span class="delimiter">;</span>
  <span class="function">memcpy_avx</span>(<span class="variable">p_src</span>, <span class="variable">p_dest</span>, <span class="number">4</span>)<span class="delimiter">;</span>
  <span class="function">fprintf</span>(<span class="variable">stdout</span>, <span class="string">&quot;p_src: %p, p_dest: %p\n&quot;</span>, (<span class="type">void</span> <span class="operator">*</span>)<span class="variable">p_src</span>, (<span class="type">void</span> <span class="operator">*</span>)<span class="variable">p_dest</span>)<span class="delimiter">;</span>
  <span class="keyword">return</span> <span class="number">0</span><span class="delimiter">;</span>
}
<span class="comment">// clang -Weverything -O3 -march=native memcpy_avx.c extern.c &amp;&amp; ./a.out</span>
<span class="comment">// Output (contains C++ warnings):</span>
<span class="comment">// extern.c:8:5: warning: unsafe pointer arithmetic [-Wunsafe-buffer-usage]</span>
<span class="comment">//     8 |     src += 1;</span>
<span class="comment">//       |     ^~~</span>
<span class="comment">// extern.c:9:5: warning: unsafe pointer arithmetic [-Wunsafe-buffer-usage]</span>
<span class="comment">//     9 |     dest += 1;</span>
<span class="comment">//       |     ^~~~</span>
<span class="comment">// 2 warnings generated.</span>
<span class="comment">// p_src: 0x7ffceb985a60, p_dest: 0x7ffceb985660</span>
</code></pre>
<figcaption>memcpy_avx.c</figcaption></figure></p></div></div></li>
                      <li><div><div id=cerberus><p> Checking C code validity with Cerberus does not imply absence of compiler miscompilations. <figure><pre><code class="bash"><span class="comment">#!/usr/bin/env bash</span>
<span class="comment"># Install opam with ocaml</span>
<span class="constant">git</span> <span class="constant">clone</span> <span class="constant">https://github.com/rems-project/cerberus</span>
<span class="constant">opam</span> <span class="constant">install</span> <span class="constant">--deps-only</span> <span class="constant">./cerberus-lib.opam</span> <span class="constant">./cerberus.opam</span>
<span class="constant">make</span>
<span class="constant">make</span> <span class="constant">install</span> <span class="constant">DESTDIR=$HOME/.local/cerberus</span>
<span class="constant">echo</span> <span class="constant">&apos;PATH=${PATH}:&quot;$HOME/.local/cerberus/bin&quot;&apos;</span> <span class="operator">&gt;&gt;</span> ~/.bashrc
<span class="constant">eval</span> <span class="constant">(opam env)</span>
<span class="constant">cerberus</span> <span class="constant">--help</span>
</code></pre>
<figcaption>cerberus_install.sh</figcaption></figure> <figure><pre><code class="c"><span class="keyword">#include</span> <span class="string">&lt;stddef.h&gt;</span>
<span class="keyword">extern</span> <span class="type">size_t</span> <span class="variable">x</span><span class="delimiter">;</span>
</code></pre>
<figcaption>extern_miscompilation.h</figcaption></figure> <figure><pre><code class="c"><span class="keyword">#include</span> <span class="string">&quot;extern_miscompilation.h&quot;</span>
<span class="type">size_t</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span><span class="delimiter">;</span>
</code></pre>
<figcaption>extern_miscompilation.c</figcaption></figure> <figure><pre><code class="c"><span class="keyword">#include</span> <span class="string">&lt;stdio.h&gt;</span>

<span class="keyword">#include</span> <span class="string">&quot;extern_miscompilation.h&quot;</span>
<span class="comment">// Removing restrict makes the miscompilation go away</span>
<span class="type">size_t</span> <span class="function">f</span>(<span class="type">size_t</span> <span class="operator">*</span>restrict <span class="variable">ptr_to_x</span>)<span class="delimiter">;</span>
<span class="type">size_t</span> <span class="function">f</span>(<span class="type">size_t</span> <span class="operator">*</span>restrict <span class="variable">ptr_to_x</span>) {
  <span class="type">size_t</span> <span class="operator">*</span><span class="variable">p</span> <span class="operator">=</span> <span class="variable">ptr_to_x</span><span class="delimiter">;</span>
  <span class="operator">*</span><span class="variable">p</span> <span class="operator">=</span> <span class="number">1</span><span class="delimiter">;</span>
  <span class="keyword">if</span> (<span class="variable">p</span> <span class="operator">==</span> <span class="operator">&amp;</span><span class="variable">x</span>) {
    <span class="comment">// Expected branch, taken only in Debug mode</span>
    <span class="operator">*</span><span class="variable">p</span> <span class="operator">=</span> <span class="number">2</span><span class="delimiter">;</span>
  }
  <span class="keyword">return</span> <span class="operator">*</span><span class="variable">p</span><span class="delimiter">;</span>
}
<span class="type">int</span> <span class="function">main</span>(<span class="type">void</span>) {
  <span class="keyword">if</span> (<span class="function">f</span>(<span class="operator">&amp;</span><span class="variable">x</span>) <span class="operator">==</span> <span class="number">1</span>)
    <span class="function">fprintf</span>(<span class="variable">stderr</span>, <span class="string">&quot;panic : p != &amp;x\n&quot;</span>)<span class="delimiter">;</span>
}
<span class="comment">// clang -O0 -Weverything ptr_provenance_miscompilation.c extern.c &amp;&amp; ./a.out</span>
<span class="comment">// output:</span>
<span class="comment">// clang -O1 -Weverything ptr_provenance_miscompilation.c extern.c &amp;&amp; ./a.out</span>
<span class="comment">// output: panic : p != &amp;x</span>
<span class="comment">// cerberus ptr_provenance_miscompilation.c extern.c</span>
<span class="comment">// output:</span>
<span class="comment">// merging everything into ptr_provenance_miscompilation.c</span>
<span class="comment">// cerberus ptr_provenance_miscompilation.c</span>
<span class="comment">// output:</span>
</code></pre>
<figcaption>ptr_provenance_miscompilation.c</figcaption></figure></p></div></div></li>
                      <li><div><div id=cheri><p> CHERI usage is left as task for the reader. Useful links are <code>https://github.com/CTSRD-CHERI/cheribuild</code>, <code>https://github.com/CTSRD-CHERI/cheri-c-programming</code> and <code>https://github.com/capablevms/cheri-examples</code>.</p></div></div></li>
                    </ol>
                  </li>
                </ol>
              </li>
              <li><div><div id=seq_pts><p> <strong>Sequence Points</strong> in simple case and with storage lifetime extension. <figure><pre><code class="c"><span class="keyword">#include</span> <span class="string">&lt;stdint.h&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;stdio.h&gt;</span>
<span class="type">int</span> <span class="function">f</span>(<span class="type">int</span> <span class="operator">*</span><span class="variable">a</span>) {
  <span class="operator">*</span><span class="variable">a</span> <span class="operator">=</span> <span class="operator">*</span><span class="variable">a</span> <span class="operator">+</span> <span class="number">1</span><span class="delimiter">;</span>
  <span class="keyword">return</span> <span class="operator">*</span><span class="variable">a</span><span class="delimiter">;</span>
}
<span class="type">void</span> <span class="function">simple_sequence_points</span>() {
  <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span><span class="delimiter">;</span>
  <span class="comment">// warning: Multiple unsequenced modifications to a</span>
  <span class="comment">// a = a++ + a++;</span>
  <span class="comment">// Problem without warnings</span>
  <span class="variable">a</span> <span class="operator">=</span> <span class="function">f</span>(<span class="operator">&amp;</span><span class="variable">a</span>) <span class="operator">+</span> <span class="function">f</span>(<span class="operator">&amp;</span><span class="variable">a</span>)<span class="delimiter">;</span>
  <span class="variable">a</span> <span class="operator">=</span> <span class="function">f</span>(<span class="operator">&amp;</span><span class="variable">a</span>)<span class="delimiter">;</span>
  <span class="variable">a</span> <span class="operator">+=</span> <span class="function">f</span>(<span class="operator">&amp;</span><span class="variable">a</span>)<span class="delimiter">;</span>
}
<span class="keyword">struct</span> <span class="type">sExample</span> {
  <span class="type">int32_t</span> <span class="property">a</span>[<span class="number">1</span>]<span class="delimiter">;</span>
}<span class="delimiter">;</span>
<span class="keyword">struct</span> <span class="type">sExample</span> <span class="function">create_sExample</span>(<span class="type">void</span>) {
  <span class="keyword">struct</span> <span class="type">sExample</span> <span class="variable">res</span> <span class="operator">=</span> {{<span class="number">1</span>}}<span class="delimiter">;</span>
  <span class="keyword">return</span> <span class="variable">res</span><span class="delimiter">;</span>
}
<span class="type">int</span> <span class="function">storage_lifetime_footgun</span>(<span class="type">void</span>) {
  <span class="comment">// undefined behavior introduced if temporary is missing</span>
  <span class="comment">// printf(&quot;%x&quot;, ++(create_fail().a[0]));</span>
  <span class="keyword">struct</span> <span class="type">sExample</span> <span class="variable">res</span> <span class="operator">=</span> <span class="function">create_sExample</span>()<span class="delimiter">;</span>
  <span class="function">printf</span>(<span class="string">&quot;%x&quot;</span>, <span class="operator">++</span>(<span class="variable">res</span><span class="delimiter">.</span><span class="property">a</span>[<span class="number">0</span>]))<span class="delimiter">;</span>
  <span class="keyword">return</span> <span class="number">0</span><span class="delimiter">;</span>
}
</code></pre>
<figcaption>sequence_points.c</figcaption></figure></p></div></div></li>
              <li><div><div id=bitfields><p> <strong>Bit-fields</strong> should not be used unless for non-portable code regarding compilers and CPUs and do not make assumptions regarding the layout of structures with bit-fields and use <code>static_assert</code>/<code>_Static_assert</code> on every struct. Keep bit-fields as simple as possible, meaning prefer not to nest them or also static_assert the layout. <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf" target="_blank">Reasons from ISO/IEC 9899:TC3</a></p><pre><code>&gt; An implementation may allocate any addressable storage unit large enough to hold a bit
&gt; field. If enough space remains, a bit-field that immediately follows another bit-field in a
&gt; structure shall be packed into adjacent bits of the same unit. If insufficient space remains,
&gt; whether a bit-field that does not fit is put into the next unit or overlaps adjacent units is
&gt; implementation-defined. The order of allocation of bit-fields within a unit (high-order to
&gt; low-order or low-order to high-order) is implementation-defined. The alignment of the
&gt; addressable storage unit is unspecified.
</code></pre><p>or in other words:</p><ul><li>1.Order of allocation not specified.</li><li>2.Most significant bit not specified.</li><li>3.Alignment is not specified.</li><li>4.Implementations can determine, whether bit-fields cross a storage unit boundary.</li><li>5.Structs may contain padding bytes anywhere.</li></ul></div></div></li>
            </ol>
          </div>
      </div>
    </div>
  </body>
</html>
