<!doctype html>
<html lang="en"><meta charset=utf-8>
<title>Some practical C++ footgun avoidance.</title>
<style>
    #contents {
      max-width: 60em;
      margin: auto;
      padding: 0 1em;
    }
    code {
      background: #f8f8f8;
      border: 1px dotted silver;
      padding-left: 0.3em;
      padding-right: 0.3em;
    }
    pre > code {
      display: block;
      overflow: auto;
      padding: 0.5em;
      border: 1px solid #eee;
      line-height: normal;
    }
    .tok-kw {
        color: #333;
        font-weight: bold;
    }
    .tok-str {
        color: #d14;
    }
    .tok-builtin {
        color: #005C7A;
    }
    .tok-comment {
        color: #545454;
        font-style: italic;
    }
    .tok-fn {
        color: #900;
        font-weight: bold;
    }
    .tok-null {
        color: #005C5C;
    }
    .tok-number {
        color: #005C5C;
    }
    .tok-type {
        color: #458;
        font-weight: bold;
    }

    <!-- figure -->
    figure {
      margin: auto 0;
    }
    figure pre {
      margin-top: 0;
    }

    figcaption {
      padding-left: 0.5em;
      font-size: small;
      border-top-left-radius: 5px;
      border-top-right-radius: 5px;
    }
    figcaption.cpp-cap {
      background: #fcdba5;
    }
    figcaption.c-cap {
      background: #a8b9cc;
      color: #000;
    }
    figcaption.peg-cap {
      background: #fcdba5;
    }
    figcaption.javascript-cap {
      background: #365d95;
      color: #fff;
    }
    figcaption.shell-cap {
      background: #ccc;
      color: #000;
    }

</style>
<div id="contents">
<div style="text-align:left; padding up down: 1em">
<h2>Some practical C++ footgun avoidance.</h2>
</div>
  Here is a list of problems I found worthwhile to write up to remind myself
  not to do the same mistake again or how to workaround various compiler problems.
  It consists of type problems, easy to make memory issues mostly around
  uninitialized memory and stack-local values,
  low quality library code, problems with virtual classes,
  template code problems and some compiler specific problems.
  For a more complete view on the edge cases of the language, consider taking a look at the
  <a href="https://github.com/fouronnes/cppiceberg">C++ iceberg</a>
  and <a href="https://github.com/JadLevesque/PPMP-Iceberg">preprocessor iceberg</a>.
  <ul>
    <li>
      Do not use <code>hashmap[key]</code>, use <code>auto search_hashmap = hashmap.find();</code>
      and write via iterator or use <code>emplace</code>, because there is no check for the elements
      existence or (typically raw C) values of members can remain undefined after object creation due to
      implicit default constructor.
      <figure><figcaption class="cpp-cap"><cite class="file">hashmap_simple_ub.cpp</cite></figcaption>
<pre><code>
<span class="line"><span class="tok-kw">class</span> T1 {</span>
<span class="line"><span class="tok-kw">public</span>:</span>
<span class="line">    T1(); // needed to allow convenient random access via [] operator</span>
<span class="line">    T1(const std::string &amp;t1): mName(t1) {};</span>
<span class="line">    std::string mName;</span>
<span class="line">    std::string prop1;</span>
<span class="line">};</span>
<span class="line"><span class="tok-kw">class</span> T2 {</span>
<span class="line"><span class="tok-kw">public</span>:</span>
<span class="line">    std::map<std::string, T1> mapex1;</span>
<span class="line">    void AddT1 (const std::string &amp;t1str) {</span>
<span class="line">        T1 t1obj(t1str);</span>
<span class="line">        mapex1.emplace(t1str, t1obj);</span>
<span class="line">        mapex1[t1str].prop1 = "blabla"; // potential footgun!</span>
<span class="line">    }</span>
<span class="line">};</span>
</code></pre>
      </figure>
    </li>

    <li>
      Providing <code>const char *</code> to a function with reference will use the stack-local
      memory instead of using a copy. If further, <code>c_str()</code> is used to
      emplace into a <code>std::map</code>, this leads to UB due to usage of invalid memory once
      the stack local memory goes out of scope.
      <ol>
        <li>In doubt, allocate a copy with <code>std::string newstring = std::string(some_string)</code></li>
        <li>Especially in <code>std::map</code> or other owned containers.</li>
        <li><b>Only</b> if there is an explicit comment on the storage including
            handling of move and copy constructor, use <code>(const) char*</code> as provided
            argument for <code>(const) std::string &amp;</code>.
        </li>
      </ol>
    </li>

    <li> There is no type safety in <code>reinterpret_cast</code> usage, which is worse than <code>memcpy</code>.
      However, the prevention of another temporary for portable code may be worth it.
      <figure><figcaption class="cpp-cap"><cite class="file">hashmap_simple_ub.cpp</cite></figcaption>
<pre><code>
<span class="line">int64_t usage_ptr(int64_t * val) {</span>
<span class="line">  return *val;</span>
<span class="line">}</span>
<span class="line">int reinterpret_cast_usage() {</span>
<span class="line">  // clang-format: off</span>
<span class="line">  uint8_t some_vals[9] = { 0</span>
<span class="line">                         , 1, 0, 0, 0</span>
<span class="line">                         , 0, 0, 0, 0 };</span>
<span class="line">  // clang-format: on</span>
<span class="line">  int64_t val_mcpy;
<span class="line">  // val_mcpy = memcpy(&amp;val_mcpy, some_vals[1], sizeof(val_mcpy);  // refusal to compile</span>
<span class="line">  val_mcpy = memcpy(&amp;val_mcpy, &amp;some_vals[1], sizeof(val_mcpy);   // refusal to compile</span>
<span class="line">  int64_t val_wrong = *reinterpret_cast<int64_t*>(some_vals[1]);            // runtime error</span>
<span class="line">  int64_t val_ok = *reinterpret_cast<int64_t*>(&amp;some_vals[1]);              // correct usage</span>
<span class="line">  int64_t * val_ok_ptr = reinterpret_cast<int64_t*>(&amp;some_vals[1]);         // correct usage</span>
<span class="line">  usage_ptr(val_ok_ptr);</span>
<span class="line">  usage_ptr(&amp;val_mcpy);                              // necessary temporary copy hopefully elided</span>
<span class="line">  <span class="tok-kw">if</span> (val != INT64_MIN) <span class="tok-kw">return</span> 1;</span>
<span class="line">  <span class="tok-kw">return</span> 0;</span>
<span class="line">}</span>
    </li>

    <li> <a href="https://stackoverflow.com/questions/11598990/is-stdstoi-actually-safe-to-use">
    C++ conversion string to int is worse without boost</a>, so use C's strtol.
    </li>

<!--     <li> -->
<!-- Template usage with base class adding to container (for example to map via emplace), -->
<!-- where the base class with interfaces is not templated, but specialized one is, -->
<!-- may have undecipherable error messages due to no automatic upcast to base class. -->
<!-- //   file.cpp:1032:64:   required from here -->
<!-- //   /usr/include/c++/9/ext/new_allocator.h:146:4: error: no matching function for call to ‘std::pair<const std::__cxx11::basic_string<char>, std::shared_ptr<FileInterface> >::pair(std::__cxx11::basic_string<char>, std::shared_ptr<File<std::__cxx11::basic_string<char> > >&amp;)’ -->
<!-- //     146 |  { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); } -->
<!-- //         |    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<!-- // It does not matter to use std::shared_ptr<Variable<std::string>> var_obj = std::make_shared<Variable<std::string>>(varValue, varName.c_str(), varPath.c_str(), varAttr); -->
<!-- //      or std::shared_ptr<Variable<std::string>> var_obj(new Variable<std::string>>(varValue, varName.c_str(), varPath.c_str(), varAttr)); -->
<!-- // Solution: -->
<!-- //   1. Make functions within interface class templated (no virtual) or purely virtual (no body and write 'virtual fnname() = 0;') -->
<!-- //   2. Remove all data from interface class -->
<!-- //   4. Check, if constructor of base class is public to make it accessible to specialized one -->
<!-- //   5. Use one of the following patterns: -->
<!-- //     + 1. fns not impacting object lifetime should use 'int foo(bar&amp; b)' -->
<!-- //     + 2. fns consuming object should use 'baseobjfn(unique_ptr<specialobj> b)' and be called with std::move to move the value into fn -->
<!-- //     + 3. fns extending lifetime object should use 'baseobjfn(shared_ptr<specialobj>)' and care should be taken to avoid circular references -->
<!--     </li> -->

    <li> Checking, if typename is a string is complex (even with C++17 extension).
      <figure><figcaption class="cpp-cap"><cite class="file">hashmap_simple_ub.cpp</cite></figcaption>
<pre><code>
<span class="line">template&lt;typename STR&gt;</span>
<span class="line">inline</span> constexpr bool is_string_class_decayed = false;</span>
<span class="line">template&lt;typename... STR&gt;</span>
<span class="line">inline constexpr bool is_string_class_decayed&lt;std::basic_string&lt;STR...&gt;&gt; = true;</span>
<span class="line">// decay_t will remove const, &amp; and volatile from the type</span>
<span class="line">template&lt;typename STR&gt;</span>
<span class="line">inline</span> constexpr bool is_string_class = is_string_class_decayed<std::decay_t<STR&gt;&gt;</span>
<span class="line">template &lt;typename TChar, typename TString&gt;</span>
<span class="line">inline constexpr bool is_string = is_string_class&lt;TString&gt; &amp;&amp; std::is_same_v&lt;TChar, typename TString::value_type&gt;;</span>
<span class="line"><span class="tok-kw">static_assert</span>(is_string_class&lt;std::string&gt;);</span>
<span class="line"><span class="tok-kw">static_assert</span>(is_string_class&lt;const std::wstring&amp;&gt;); // that's why we need decay_t</span>
<span class="line"><span class="tok-kw">static_assert</span>(!is_string_class&lt;int&gt;);</span>
<span class="line"><span class="tok-kw">static_assert</span>(!is_string_class&lt;const double&gt;);</span>
<span class="line"><span class="tok-kw">static_assert</span>(!is_string_class&lt;const char*&gt;);</span>
<span class="line"><span class="tok-kw">static_assert</span>(!is_string_class&lt;&lt;std::vector&lt;char&gt;&gt;);</span>
</code></pre>
      </figure>
    </li>

    <li>
      <code>auto</code> does verbatim replacement of the return type, which can hide a stack-local copy.
      <b>Only</b> use 'auto' for well-known iterators, status tuples, shared pointers etc, but <b>never</b> for
      objects and object references.
    </li>

    <li> Interoperating type safe with c strings is cumbersome.
      <figure><figcaption class="cpp-cap"><cite class="file">hashmap_simple_ub.cpp</cite></figcaption>
<pre><code>
<span class="line">void cstring_string_interop() {</span>
<span class="line">  const char * cmd = "ls";</span>
<span class="line">  char const * buffer[] = {"ls", "-l", NULL};</span>
<span class="line">  char * const * argv = const_cast<char * const *>(buffer);</span>
<span class="line">  int execed = execve(cmd, argv, NULL);</span>
<span class="line">  (void)execed;</span>
<span class="line">}</span>
</code></pre>
      </figure>
    </li>

    <li> MSVC has no reliable relative paths as macro yet (see experimental:deterministic mode).
        Workaround get filename by Andry https://stackoverflow.com/a/54335644.
      <figure><figcaption class="cpp-cap"><cite class="file">hashmap_simple_ub.cpp</cite></figcaption>
<pre><code>
<span class="line">template <typename T, size_t S></span>
<span class="line">inline constexpr size_t fname_offs(const T(&amp;str)[S], size_t i = S - 1) {</span>
<span class="line">  return (str[i] == '/' || str[i] == '\\') ? i + 1 : (i &gt; 0 ? fname_offs(str, i - 1) : 0);</span>
<span class="line">}</span>
<span class="line">template <typename T></span>
<span class="line">inline constexpr size_t fname_offs(T(&amp;str)[1]) {</span>
<span class="line">  return 0;</span>
<span class="line">}</span>
<span class="line">namespace util_force_const_eval {</span>
<span class="line">  template <typename T, T v></span>
<span class="line">  struct const_expr_value</span>
<span class="line">  {</span>
<span class="line">    static constexpr const T value = v;</span>
<span class="line">  };</span>
<span class="line">}</span>
<span class="line">#define FORCE_CONST_EVAL(exp) ::util_force_const_eval::const_expr_value<decltype(exp), exp>::value</span>
<span class="line">#define LEAF(FN) (&amp;FN[FORCE_CONST_EVAL(fname_offs(FN))])</span>
<span class="line"></span>
<span class="line">int testEq(int a, int b) {</span>
<span class="line">  if (a != b) {</span>
<span class="line">    // Prefer __FILE_NAME__, which also works in C. Ideally, the compiler</span>
<span class="line">    // can be told to provide relative file paths.</span>
<span class="line">    fprintf(stderr,"%s:%d got '%d' expected '%d'\n", LEAF(__FILE__), __LINE__, a, b);</span>
<span class="line">    return 1;</span>
<span class="line">  }</span>
<span class="line">  return 0;</span>
<span class="line">}</span>
</code></pre>
      </figure>
    </li>

    <li>
      Destructors of virtual classes should have lifetime annotation, unless
      final class. Otherwise, debugging problems will be painful, because the
      intended object lifetimes become ambiguous on reading the code. Consider
      using <code>clang -Wnon-virtual-dtor</code> or recent msvc (~ year 2020).
    </li>

    <li> Delete copy + move constructors for non-final classes with no pure-virtual methods.</li>

    <li>
      Consider marking copy constructor as explicit and deleting copy assignment, if
      copying class is expensive. Consider providing a "clone fn" as syntactic sugar.
    </li>

    <li>
      Do not use <code>std::vector&lt;bool&gt;</code>, because it is a
      bitset and has horrible naming. Accidental byte operations on
      it like <code>memcpy</code> will be UB.
    </li>

  </ul>
</div>
</html>