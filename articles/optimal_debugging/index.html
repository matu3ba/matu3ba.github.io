<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Jans Website</title>
    <link rel="stylesheet" type="text/css" href="/normalize.css">
    <link rel="stylesheet" type="text/css" href="/style.css">
  </head>
  <body>
    <div class="home_page">
      <div class='static_grid'>
          <div class='static_double_column1'>
            <h1><span class="reset_a"><a href="/">Jans Website.</a></span> <span class="reset_a"><a href="/articles/about/">About.</a></span></h1>
          </div>
          <div class='static_double_column2'>
            <h2>Towards optimal an optimal debugging library framework</h2>
          </div>
          <div class='static_double_column3'>
            <div><div id=intro><p> This article is intended as overview of debugging techniques and motivation for uniform execution representation and setup to efficiently mix and match the appropriate technique for system level debugging with focus on statically optimizing compiler languages to keep complexity and scope limited. The author accepts the irony of such statements by “C having no ABI”/many systems in practice having no ABI, but reality is in this text simplified for brevity and sanity.</p><ul><li>1.<a href="#theory">Theory of debugging</a></li><li>2.<a href="#practice">Practical methods with tradeoffs</a></li><li>3.<a href="#uniform_execution_representation">Uniform execution representation</a></li><li>4.<a href="#abstraction_problems">Abstraction problems during problem isolation</a></li><li>5.<a href="#possible_implementations">Possible implementations</a></li></ul></div></div>
            <div><div id=theory><h3>Theory of debugging</h3><p>A program <a href="https://gu.outerproduct.net/debug.html" target="_blank">can be represented as (often non-deterministic) state machine</a>, such that a <strong>bug</strong> is a <strong>bad transition rule</strong> between those states. It is usually assumed that the developer/user knows correct and incorrect (bad) system states and the code represents a somewhat correct model of the intended semantics. Then an execution witness are the states and state transitions encountered on a specific program run. If the execution witness shows a “bad state”, then there must be a bug. Thus a <strong>debugger</strong> can be seen <strong>as query engine over states and transitions of a buggy execution witness.</strong><br>Frequent operations are bug source isolation to deterministic components, where encapsulation of non-determinism usually simplifies the process. In contrast to that, concurrent code is tricky to debug, because one needs to trace multiple execution flows to estimate where the origin of the incorrect state is.</p><p>One can generally categorize methods into the following list (<strong>asoul</strong>) <strong>a</strong>utomate, <strong>s</strong>implify, <strong>o</strong>bserve, understand, learn)</p><ul><li><strong>a</strong>utomate the process to minimize errors/oversights during debugging, against probabilistic errors, document the process etc</li><li><strong>s</strong>implify and isolate system components and changes over time</li><li><strong>o</strong>bserve the system while running it to <em>trace state or state changes</em></li><li><strong>u</strong>nderstand the expected and actual code semantics to the degree necessary</li><li><strong>l</strong>earn, extend and ensure how and which system invariants are satisfied necessary from <em>of the involved systems</em>, for example userspace processes, kernel, build system, compiler, source code, linker, object code, assembly, hardware etc</li></ul><p>with the fundamental constrains being (<strong>feel</strong>)</p><ul><li><strong>f</strong>inding out correct system components semantics</li><li><strong>ee</strong>nsuring deterministic reproducibility of the problem</li><li><strong>l</strong>imited time and effort</li></ul><p>Common debugging methods to <strong>feel a soul</strong> with various tradeoffs from compile-time to runtime debugging and less to more run-time data collection are:</p><ul><li><strong>Formal Verification</strong> as ahead or compile-time invariant resolving.</li><li><strong>Validation</strong> as runtime invariant checks.</li><li><strong>Testing</strong> as sample based runtime invariant checks.</li><li><strong>Stepping</strong> via “classical debugger” to manipulate task execution context, manipulate memory optionally via source code location translation via REPL commands, graphically, scripting or (rarely) freely programmable.</li><li><strong>Logging</strong> as dumping (a simplification of) state with context from bugs (usually timestamps in production systems).</li><li><strong>Tracing</strong> as dumping (a simplification of) runtime behavior via temporal relations (usually timestamps).</li><li><strong>Recording</strong> Encoded dumping of runtime to replay runtime with before specified time and state determinism.</li></ul><p>Simplification and isolation means to apply the meaning of both words on all potential sub-components including, but not limited to hardware, code versioning including dependencies, source system, compiler framework and target system. Typical methods are</p><ul><li><strong>Bisection</strong> via git or the actual binaries</li><li><strong>Reduction</strong> via rmeoval of system parts or trying to reproduce with (a minimal) example.</li><li><strong>Statistical analysis</strong> from collected data on how the problem manifests on given environment(s) etc.</li></ul><p><strong>Debugging</strong> is domain- and design-specific and <strong>relies on</strong> core component(s) of <strong>the to be debugged system to provide necessary debug functionality</strong>. For example, software based hardware debugging relies on interfaces to the hardware like JTAG, Kernel debugging on Kernel compilation or configuration and elevated (user), userspace debugging on process and user permissions, system configuration or a child process to be debugged on Posix systems via ptrace.</p></div></div>
            <div><div id=practice><h3>Practical methods with tradeoffs</h3><p>Usually semantics are not “set into stone” inclusive or do not offer sufficient tradeoffs, so formal verification is rarely an option aside of usage of models as design and planning tool. Depending on the domain and environment, problematic behavior of hardware or software components must be to be more or less 1. avoided and 2. traceable and there exist various (domain) metrics as decision helper. Very well designed systems explain users how to debug bugs regarding to <strong>functional behavior</strong>, <strong>time behavior</strong> with <strong>internal and external system resources</strong> up to the degree the system usage and task execution correctness is intended. Access restrictions limit or rule out stepping, whereas storage limitations limit or rule out logging, tracing and recording.</p></div></div>
            <!--<div :html="$page.content()"></div>-->
            <ol>
              <li> <a id ="hardware_problems"><b>Hard(ware) problems</b></a>
                <a href="https://interrupt.memfault.com/blog/schematic-review-checklist">
                Hardware design reviews</a>
                with extensive focus on core components
                (power, battery, periphery, busses, memory/flash and debug/test infrastructure)
                to enable debugging and component tests against product and assembling defects
                are fundamental for software debugging under assumption that computing unit(s)
                and memory unit(s) can be trusted to work reliable enough.
                Depending on goals, time channel analysis, formal methods to rule out logic
                errors and fuzzing against bad temporal behavior (for example during speculative execution)
                are common methods besides various testing strategies based on statistical analysis.
              </li>
              <li> <a id ="platform_problems"><b>Kernel and platform problems</b></a>
                The managing environment the code is running on can vary a lot.
                As example, the typical four phases of the Linux boot process
                (system startup, bootloader stage, kernel stage, and init process)
                have each their own debugging infrastructure and methods.
                Generally, working with (introspection-restricted) platforms requires
                1. reverse engineering and "trying to find info" and/or 2. "use some tracing
                tool" and for 3. open source "adjust the source and stare at kernel
                dumps/use debugger".
                Kernels are rarely designed for tracing, recording, formal
                verification due to internal complexity and virtualization is slow and
                hides many classes of synchronization bugs.
                Due to being complex, moving targets, having no library design, having design flaws
                and many performance tradeoffs, they are hard to fuzz test.
              </li>
              <li> <a id ="detectable_ub"><b>Detectable Undefined Behavior</b></a>
                TODO make table of tools, C,C++,zig -OReleaseSafe
              </li>
              <li> <a id ="undetectable_ub"><b>Undetectable Undefined Behavior</b></a>
                Staring at source code, backend intermediate representation like LLVM
                IR and reducing the problem or resulting assembly. Unfortunately the
                backend optimizers like LLVM do not offer frontend language writers
                debug APIs and related tooling due to not being designed for that
                purpose.
              </li>
              <li> <a id ="miscomplations"><b>Miscompilations</b></a>
                Tools like Miri or Cerberus run the program in an interpreter,
                but may not cover all possible program semantics due to ambiguity
                and may not be feasible, so the only good chance is to reduce it.
              </li>
              <li> <a id ="memory_problems"><b>Memory problems</b></a>
                sanitizers, validators, simulator, tracers: TODO table with configs and costs
                - 1.out-of-bounds access sanitizer
                - 2.null pointer dereference sanitizer
                - 3.type confusion sanitizer
                - 4.integer overflow sanitizer
                - 5.use after free sanitizer
                - 6.invalid stack access sanitizer
                - 7.usage of uninitialized memory sanitizer
                - 8.data races sanitizer
              </li>
              <li> <a id ="resource_leaks"><b>Resource leaks (Freestanding/Kernel)</b></a>
                TODO sanitizers (valgrind etc)
              </li>
              <li> <a id ="freezes"><b>Freezes (deadlocks, softlocks, signal safety, unbounded loops etc)</b></a>
                TODO sanitizer, validator, stepping
              </li>
              <li> <a id ="perf_problems"><b>Performance problems</b></a>
                TODO simulator, tracer
              </li>
              <li> <a id ="logic_problems"><b>Logic problems</b></a>
                Logic problems of software systems can be described as problems
                related to incorrectly applied logic of how the code is solving the
                intended and follow-up problems ignoring hardware problems, kernel
                problems, different types of UB, miscompilations, memory problems,
                resource leaks, freezes and performance issues. <br>
                This typically includes
                <ol>
                  <li>software requirements or their handling</li>
                  <li>(temporary) inconstency of state (relations)</li>
                  <li>incorrect math, for example not covering edge cases</li>
                  <li>incorrect modeling of external and internal state and synchronization</li>
                  <li>incorrect protocol handling</li>
                </ol>
                and is usually caused by
                <ol>
                  <li> incorrect constrains on the design, meaning how the different
                    parts should interact and work towards the goals for the use
                    cases</li>
                  <li> unclear, unspecified or incorrectly assumed hardware or software
                    guarantees by components </li>
                  <li> implementation oversights, unintended use cases, unfeasibility
                    of a general solution due to constrains like time, money etc</li>
                </ol>
              </li>
            </ol>
            Ideally, only the system behavior and interactions with domain and
            use-case specific parts (<b>2. Kernel and platform problems</b>,
            <b>10. Logic problems</b>) need cognitive load from the programmer, whereas
            the other error classes should have standard approaches to isolate and eliminate.
            Unifying debug tooling simplifies usage for bigger developer productivity
            and exposing as library allows to automate this process.
          </div>
      </div>
    </div>
  </body>
</html>
