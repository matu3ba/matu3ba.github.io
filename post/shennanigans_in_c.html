<!doctype html>
<html lang="en"><meta charset=utf-8>
<title>Pointers, sequence points and bit fields in C.</title>
<style>
    #contents {
      max-width: 60em;
      margin: auto;
      padding: 0 1em;
    }
    code {
      background: #f8f8f8;
      border: 1px dotted silver;
      padding-left: 0.3em;
      padding-right: 0.3em;
    }
    pre > code {
      display: block;
      overflow: auto;
      padding: 0.5em;
      border: 1px solid #eee;
      line-height: normal;
    }
    .tok-kw {
        color: #333;
        font-weight: bold;
    }
    .tok-str {
        color: #d14;
    }
    .tok-builtin {
        color: #005C7A;
    }
    .tok-comment {
        color: #545454;
        font-style: italic;
    }
    .tok-fn {
        color: #900;
        font-weight: bold;
    }
    .tok-null {
        color: #005C5C;
    }
    .tok-number {
        color: #005C5C;
    }
    .tok-type {
        color: #458;
        font-weight: bold;
    }
    <!-- figure -->
    figure {
      margin: auto 0;
    }
    figure pre {
      margin-top: 0;
    }

    figcaption {
      padding-left: 0.5em;
      font-size: small;
      border-top-left-radius: 5px;
      border-top-right-radius: 5px;
    }
    figcaption.c-cap {
      background: #fcdba5;
    }
    figcaption.peg-cap {
      background: #fcdba5;
    }
    figcaption.javascript-cap {
      background: #365d95;
      color: #fff;
    }
    figcaption.shell-cap {
      background: #ccc;
      color: #000;
    }

</style>
<div id="contents">
<div style="text-align:left; padding up down: 1em">
<h2>C shennanigans.</h2>
</div>
  This text focuses on some of the non-obvious and easy to make mistakes
  non-experienced C programmers are likely to make and are/can not completely
  be covered by tooling without going into edge cases relevant to performance
  and covering the most simple and conservative approach:
  <ol>
    <li><a href="#pointer_semantics">Pointer semantics</a></li>
    <li><a href="#seq_pts">Sequence points</a></li>
    <li><a href="#bitfields">Bit-fields</a></li>
  </ol>
  Compiler flags or implementation may provide workarounds to these problems
  to prevent optimizations based on introduced Undefined Behavior (UB).
  Review used C compilers with flags used including tests and platforms before
  reusing of any code. The
  <a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152200">SEI wiki covers some basic cases</a>
  without covering compiler workarounds.
  Pointer construction is widely unspecified in earlier C standards before
  C11 and up to this day with C23 pointer semantics have no formal model, see also
  item <a href="#pointer_construction_reqirements">pointer construction requirements</a>.
<ol>
  <li><a id ="pointer_semantics"><b>Pointer semantics</b> in C</a>.
    <ol>
      <li><a href="#pointer_access_requirements">Pointer access requirements</a></li>
      <li><a href="#pointer_access_practice">Pointer access in practice</a></li>
      <li><a href="#pointer_exceptions">The Exceptions</a></li>
      <li><a href="#pointer_construction_reqirements">Pointer construction requirements</a></li>
      <li><a href="#pointer_construction_practice">Pointer construction in practice</a></li>
    </ol>
    <br>
    <ol>
      <li> <a id="pointer_access_requirements"><b>Pointer access requirements</b></a> are fairly well specified from C89 on in
        strong contrast to <a href="#pointer_construction_reqirements">pointer construction requirements</a> and programmers with knowledge
        of how processing hardware works can derive below information.
        <ol>
          <li><span>Proper alignment</span></li>
            <ul>
              <li><span>Cleanly accessing a pointer with increased alignment requires
                <a href="https://stackoverflow.com/questions/7059299/how-to-properly-convert-an-unsigned-char-array-into-an-uint32-t">to use a temporary with memcopy</a>.</span></li>
              <li><span>To only compare pointers decrease alignment with <code>char*</code> pointer.</span></li>
              <li><span>To prune type info for generics use <code>void*</code> pointer.</span></li>
              <li><span>You are responsible to call a function that provides or provide yourself.</span></li>
            </ul>
          <li><span>Sufficient storage (pointer must point to valid object)</span></li>
          <li><span>Sufficient padding (ie withing structs).</span></li>
          <li><span>Correct aliasing</span>
            <ul>
              <li><a id="strict_aliasing_rule"><b>"Strict Aliasing Rule"</b></a><br>
<!-- https://gist.github.com/shafik/848ae25ee209f698763cffee272a58f8 -->
                &gt; An object shall have its stored value accessed only by an lvalue expression
                &gt; that has one of the following types
                &gt; — a type compatible with the effective type of the object,
                &gt; — a qualified version of a type compatible with the effective type of the object,
                &gt; — a type that is the signed or unsigned type corresponding to the effective type of the
                &gt; object,
                &gt; — a type that is the signed or unsigned type corresponding to a qualified version of the
                &gt; effective type of the object,
                &gt; — an aggregate or union type that includes one of the aforementioned types among its
                &gt; members (including, recursively, a member of a subaggregate or contained union), or
                &gt; — a character type.
                What this means in practice:<br>
                Each pointer has an associated "provenance" it is allowed to point to.
                This mean that a pointer <code>ptr</code> must uphold
                <code>(&amp;array[0] &lt;= ptr &amp;&amp; ptr &lt; &amp;array[len+1]) || ptr != 0)</code>.
                for access with array being the "memory origin range" on stack or heap.
                Pointers must point to the same array, when being used for arithmetic.<br>
                Function arguments of identical pointer types are allowed to have
                overlapping provenance regions, unless annotated with <code>__restrict__</code>,
                but pointers of different types are not allowed to have those regions.
                Pointer comparison must be done via identical alignments, for
                example to compare a pointer against pointer to 0 (usually
                abbreviated via macro <code>NULL</code>).<br>
              </li>
            </ul>
          </li>
        </ol>
      </li>
      <li> <a id="pointer_access_practice"><b>Pointer access</b> in <b>practice</b></a>.
        <ul>
          <!-- <span class="tok-kw"></span> -->
          <li><span>Provenance as regions pointer is allowed to point to for access.</span>
      <figure><figcaption class="c-cap"><cite class="file">provenance.c</cite></figcaption>
<pre><code><span class="line"><span class="tok-type">void</span> use_ptr(<span class="tok-kw">int</span> * ptr) {</span>
<span class="line">  <span class="tok-kw">printf</span>("0: %d, 9: %d\n", arr[0], arr[9]);</span>
<span class="line">}</span>
<span class="line"><span class="tok-type">void</span> main() {</span>
<span class="line">  <span class="tok-type">int</span> arr1[10]</span>
<span class="line">  use_ptr(arr1);</span>
<span class="line">  <span class="tok-type">int</span> * arr2 = <span class="tok-kw">malloc</span>(<span class="tok-kw">sizeof</span>(int));</span>
<span class="line">  use_ptr(arr2);</span>
<span class="line">  <span class="tok-kw">free</span>(arr2);</span>
<span class="line">}</span>
</code></pre></figure>
          </li>
          <li><span>Copy around some bytes from not overlapping regions (otherwise use memmove).</span>
      <figure><figcaption class="c-cap"><cite class="file">copy_bytes.c</cite></figcaption>
<pre><code><span class="line"><span class="tok-type">void</span> use_bytes(uint8_t * bytes, int32_t len_bytes, uint32_t * output, int32_t len_output) {</span>
<span class="line">  <span class="tok-kw">for</span>(<span class="tok-type">int</span> i=0; i*4&lt;len_bytes &amp;&amp; i&lt;len_output; i+=4) {</span>
<span class="line">    <span class="tok-kw">memcpy</span>(&amp;output[i], &amp;bytes[4*i], <span class="tok-kw">sizeof</span>(len_output));
<span class="line">  }</span>
<span class="line">}</span>
</code></pre></figure>
          </li>
          <li><span>Correct alignment of pointers with temporary, when necessary.</span>
      <figure><figcaption class="c-cap"><cite class="file">correct_alignment.c</cite></figcaption>
<pre><code><span class="line"><span class="tok-type">int</span> ptr_no_reinterpret_cast() {</span>
<span class="line">  <span class="tok-type">uint8_t</span> arr[4] = {0,0,0,1};</span>
<span class="line">  <span class="tok-comment">// unnecessary variable hopefully elided</span></span>
<span class="line">  <span class="tok-type">uint32_t</span> u32_arr = 0;</span>
<span class="line">  <span class="tok-kw">memcpy</span>(&amp;u32_arr, &amp;arr[0], 4);</span>
<span class="line">  <span class="tok-type">uint32_t</span> * u32_arr_ptr = &amp;u32_arr;</span>
<span class="line">  <span class="tok-comment">// &lt;use u32_arr_ptr here&gt;</span></span>
<span class="line">  <span class="tok-comment">// Footgun: Dont return stack local variables</span></span>
<span class="line">  <span class="tok-kw">return</span> 0;
<span class="line">}
</code></pre></figure>
          </li>
          <li><span>Ensure correct storage and padding size for pointers via sizeof.</span>
      <figure><figcaption class="c-cap"><cite class="file">storage_padding.c</cite></figcaption>
<pre><code><span class="line"><span class="tok-type">struct</span> sStruct1 {</span>
<span class="line">  uint8_t a1;</span>
<span class="line">  uint8_t a2;</span>
<span class="line">  uint32 b1;</span>
<span class="line">  uint32 b2;</span>
<span class="line">}</span>
<span class="line"><span class="tok-type">void</span> padding() {</span>
<span class="line">  <span class="tok-kw">struct</span> sStruct1 * str1 = <span class="tok-kw">malloc</span>(<span class="tok-kw">sizeof</span>(sStruct1)); </span>
<span class="line">  str1.a1 = 5;</span>
<span class="line">  <span class="tok-kw">free</span>(str1);</span>
<span class="line">}</span>
</code></pre></figure>
          </li>
          <li><span>Allowed aliasing of pointers</span>
      <figure><figcaption class="c-cap"><cite class="file">allowed_aliasing.c</cite></figcaption>
<pre><code><span class="line"><span class="tok-type">void</span> allowed_aliasing(uint16_t * bytes, int32_t len_bytes, uint16_t * lim) {</span>
<span class="line">  <span class="tok-kw">for</span>(<span class="tok-type">int</span> i=0; i&lt;len_bytes; i+=1) {</span>
<span class="line">    <span class="tok-kw">if</span> (bytes == lim) break</span>;
<span class="line">    bytes[i] = 42;</span>
<span class="line">  }</span>
<span class="line">}</span>
</code></pre></figure>
          </li>
          <li><span>Non-Allowed aliasing of pointers: See example correct_alignment.c</span></li>
        </ul>
      </li>
      <li> <a id="pointer_exceptions"><b>The Exceptions</b></a>.
        <ul>
          <li>
            <span>Controlling the build system + compiler invocation to opt-out of provenance based optimizations.</span><br>
            <ol>
              <li><span>Clang and gcc have <code>-fno-strict-aliasing</code>, msvc and tcc do not implement strict aliasing based optimizations.</span></li>
              <li><span>Usage of <code>restrict</code> can be en/disabled in all compilers via <code>#pragma optimize("", on/off)</code>.</span></li>
              It can also be disabled in all compilers via <code>#define restrict</code>, using an according optimization level
                (typical -O1) or via separating header and implementation and disabling link time optimziations.</span></li>
            </ol>
          </li>
          <li><span>Posix extension and Windows in practice enable dynamic linking via casting pointers <code>void *</code>to function pointers and back.
              This also means that <code>sizeof (function pointer) == sizeof (void *)</code> must be uphold, which is not true for microcontrollers
              with separate address space for code and data or
              <a href="https://cnlelema.github.io/memo/en/cheri/cheri-c-model/">CHERI in mixed capability mode/hybrid compilation mode</a>.
              Address space annotations are mandatory for this to work and it is unfortunate that standards do not reflect this as of 20240428.
            </span>
      <figure><figcaption class="c-cap"><cite class="file">aliasing_exceptions_uniform_address_space.c</cite></figcaption>
<pre><code><span class="line"><span class="tok-type">void</span> aliasing_exceptions_uniform_address_space() {</span>
<span class="line">  <span class="tok-kw">typedef</span> <span class="tok-type">int</span>(*pfn_add_one)(<span class="tok-type">int</span>);</span>
<span class="line">  <span class="tok-type">int</span> add_one(<span class="tok-type">int</span> x) = { return x+1; } </span>
<span class="line">  <span class="tok-type">void</span> usage(<span class="tok-type">int</span> x) {</span>
<span class="line">    // read fn ptr from external code
<span class="line">    <span class="tok-type">void</span> * pv_add_one = (void*)external_memory;</span>
<span class="line">    <span class="tok-kw">pfn_add_one</span> pfn_add_one_casted = (pfn_add_one)pv_add_one;</span>
<span class="line">    <span class="tok-kw">int</span> res = pfn_add_one_casted(1);</span>
<span class="line">    assert(res == 1);</span>
<span class="line">  }</span>
<span class="line">}</span>
</code></pre></figure>
          </li>
        </ul>
      </li>
      <li> <a id="pointer_construction_reqirements"><b>Pointer construction requirements</b></a>
        are unspecified in all C standards with potentially some hints and nothing
        concrete up to including C23 which further implies that pointer
        semantics have no formal model.
        At least a few possible formal models exist
        (paper VIP: Verifying Real-World C Idioms with Integer-Pointer Casts,
        N2676, P2318R1: A Provenance-aware Memory Object Model for C) so far without
        taking into account CHERI in mixed capability mode/hybrid compilation mode
        and from what I understand without taking all equivalence classes of
        pointer operations into account.
        <br>
        Therefore it is best to use the most conservative approach xor to provide
        the set of chosen (non-portable) compiler semantics in the build system
        next to the code to remove room for ambiguity.<br>
        For further information about this, take a look into paper "Subtleties of
        the ANSI/ISO C standard" and "n2263: Clarifying Pointer Provenance v4".<br>
        To simplify things, we can however extend the
        <a href="#strict_aliasing_rule">strict aliasing rule</a>
        pointer construction with shortcomings regarding
        "effective type" on type punning for hardware related programming.
        TODO quote pointer comparison rule
        * equal only for identical provenance and inside the boundaries or
        NULL
        * justify why "undefined pointers" from external code is reasonable
        on worst case fat LTO
        Strictly applying the This means that generated pointers must uphold
        <code>(&amp;array[0] &lt;= ptr &amp;&amp; ptr &lt;= &amp;array[len+1]) || ptr == 0 || ptr = undefined)</code>
        with <code>ptr == 0</code> and undefined pointers being the exceptions.<br>
        TODO double check https://gist.github.com/shafik/848ae25ee209f698763cffee272a58f8
        <br>
        Besides that, the following special cases of pointer operations are to be taken into
        account, when discussing provenance based optimizations
        unless the optimizer can prove sufficient properties are uphold:
        <ol>
          <li><a href="#ptrintconv">Pointer to integer and integer to pointer conversion</a>.
            <b>Pointer/integer to integer/pointer conversion</b> mandates in all suggested
            models for pointer semantics (of C) to prevent provenance based
            optimizations unless the optimizer can prove with certainty the origin
            of pointer provenance <b>and/or</b> programmers must/can annotate
            provenance information to pointers to guide the optimizer about which
            memory relations can and can not be optimized.
          </li>
          <li><a href="#opaque">Opaque type and pointer conversion with usage</a>.
            <b>Opaque</b> types provide a way to guarantee correct usage of object and
            pointer properties for a library or API user
            and thus should be preferred, if feasible.
          </li>
          <li><a href="#headers">Headers/exports exposing data structures, pointers to data structures and void pointers</a>.</li>
            <b>Link time optimization (LTO</b>) works across across header and
            object boundaries if sufficient information/artefacts for caller and
            callee are given, so usage of aliasing pointers in headers may lead to
            undefined behavior due to applied optimizations as motivated in
            <a href="#pointer_construction_reqirements">pointer construction requirements</a>.
          <li><a href="#intrinsics">Compiler intrinsics for IO: memcmp, memcpy, memmove, memset</a>.</li>
            <b>IO Compiler intrinsics</b> semantics are yet to be taken portably into account
            due to a lot legacy code relying on certain properties and pointer properties
            like alignment being implicit.
            Technically optimizations are possible with annotating sufficient pointer information
            and useful for accelerating intrinsics via SIMD or SWAR techniques and
            tracking provenance along pointers, like for different addressing modes or
            capabilities in CHERI, would be further useful.
        </ol>
      <li> <a id="pointer_construction_practice"><b>Pointer construction</b> in <b>practice</b></a>.
        <ol>
          <li><span><a id="ptrintconv">Pointer to integer and integer to pointer conversion</a>.<span>

// careful with segmented address spaces (lookup uintptr_t semantics in this case)
void ptrtointtoptr() {
  void *mem = malloc(1024+15);
  // C89: void *ptr = ((char *)mem+15) & ~0x0F;
  void *ptr = ((uintptr_t)mem+15) & ~ (uintptr_t)0x0F;
  memset_16aligned(ptr, 0, 1024);
  free(mem);
}
          </li>
          <li><span><a id="opaque">Opaque type and pointer conversion with usage.<span>
// opaque.h
struct item;
size_t item_size(void);
voitem id_setid(struct item * it, int32_t id);
int item_getid(struct item * it);
// opaque.c
#include opaque.h
struct item { int32_t id; };
size_t item_size(void) { return sizeof(struct item); }
voitem id_setid(struct item * it, int32_t id) { it->id = id; }
int item_getid(struct item * it) { return it->id; }
          </li>
          <li><span><a id="headers">Headers/exports exposing data structures, pointers to data structures and void pointers</a><span>
          Headers/exports prevent aliasing based optimizations, if LTO is not used, but
// lto_breaks_this.h
// TODO same provenance example across headers
// lto_breaks_this.c
#include lto_breaks_this.h
     struct item;
     size_t item_size(void);
     voitem id_setid(struct item * it, int32_t id);
     int item_getid(struct item * it);

     struct item { int32_t id; };
     size_t item_size(void) { return sizeof(struct item); }
     voitem id_setid(struct item * it, int32_t id) { it->id = id; }
     int item_getid(struct item * it) { return it->id; }

          </li>
          <li><span><a id="intrinsics">Compiler intrinsics for IO: memcmp, memcpy, memmove, memset</a>.<span>
TODO list the intrinsics
memcmp
memcpy
memmove
memset
check zig compiler_rt for other needed c routines

          </li>
          <!-- I'd be very curious about weird embedded compiler semantics in C89 and C99 due -->
          <!-- to reading paper "Subtleties of the ANSI/ISO C standard". -->
          <!-- https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1637.pdf and how much stuff -->
          <!-- https://www.cl.cam.ac.uk/~pes20/cerberus/clarifying-provenance-v4.html#q3.-can-one-make-a-usable-pointer-via-casts-to-intptr_t-and-back -->
          <!-- https://cs61.seas.harvard.edu/site/2018/Datarep4/ -->
        </ol>
      </li>
    </ol>
  <li> <a id="seq_pts"><b>Sequence Points</b></a> in simple case and with storage lifetime extension.
  <figure><figcaption class="c-cap"><cite class="file">sequence_points.c</cite></figcaption>
<pre><code><span class="line"><span class="tok-type">int</span> f(<span class="tok-type">int</span>* a) {</span>
<span class="line">  *a=*a+1;</span>
<span class="line">  return *a;</span>
<span class="line">}</span>
<span class="line"><span class="tok-type">void</span> simple_sequence_points() {</span>
<span class="line">  <span class="tok-type">int</span> a = 0;</span>
<span class="line">  <span class="tok-comment">// warning: Multiple unsequenced modifications to a</span></span>
<span class="line">  <span class="tok-comment">// a = a++ + a++;</span></span>
<span class="line">  <span class="tok-comment">// Problem without warnings</span></span>
<span class="line">  <span class="tok-comment">a = f(&amp;a) + f(&amp;a);</span></span>
<span class="line">  a = f(&amp;a);</span>
<span class="line">  a += f(&amp;a);</span>
<span class="line">}</span>
<span class="line"><span class="tok-type">struct</span> sExample { <span class="tok-type">int32_t</span> a[1]; };</span>
<span class="line"><span class="tok-type">struct</span> sExample create_sExample(void) {</span>
<span class="line">  <span class="tok-type">struct</span>t X res = { { 1 } };</span>
<span class="line">  <span class="tok-kw">return</span> res;</span>
<span class="line">}</span>
<span class="line"><span class="tok-type">int</span> storage_lifetime_footgun(void) {</span>
<span class="line">  <span class="tok-comment">// undefined behavior introduced if temporary is missing</span>
<span class="line">  <span class="tok-comment">// printf("%x", ++(create_fail().a[0]));</span></span>
<span class="line">  <span class="tok-type">struct</span> sExample res = create_sExample();</span>
<span class="line">  <span class="tok-kw">printf</span>("%x", ++(res.a[0]));</span>
<span class="line">  return 0;</span>
<span class="line">}</span>
</code></pre></figure>
  </li>
  <li> <a id="bitfields"><b>Bit-fields</b></a> should not be used unless for non-portable code regarding compilers
    and CPUs and do not make assumptions regarding the layout of structures
    with bit-fields and use <code>static_assert/_Static_assert</code> on every struct.
    Keep bit-fields as simple as possible, meaning prefer not to nest them or also
    <code>static_assert</code> the layout.<br>
    <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf">Reasons from ISO/IEC 9899:TC3</a><br>
    &gt;  An implementation may allocate any addressable storage unit large enough to hold a bit<br>
    &gt;  field. If enough space remains, a bit-field that immediately follows another bit-field in a<br>
    &gt;  structure shall be packed into adjacent bits of the same unit. If insufficient space remains,<br>
    &gt;  whether a bit-field that does not fit is put into the next unit or overlaps adjacent units is<br>
    &gt;  implementation-defined. The order of allocation of bit-fields within a unit (high-order to<br>
    &gt;  low-order or low-order to high-order) is implementation-defined. The alignment of the<br>
    &gt;  addressable storage unit is unspecified.<br>
    or in other words:
    <ol>
      <li>Order of allocation not specified.</li>
      <li>Most significant bit not specified.</li>
      <li>Alignment is not specified.</li>
      <li>Implementations can determine, whether bit-fields cross a storage unit boundary.</li>
      <li>Structs may contain padding bytes anywhere.</li>
    </ol>
  </li>
</ol>
</div>
</html>