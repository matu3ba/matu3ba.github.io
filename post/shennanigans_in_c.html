<!doctype html>
<html lang="en"><meta charset=utf-8>
<title>Pointers, sequence points and bit fields in C.</title>
<style>
    #contents {
      max-width: 60em;
      margin: auto;
      padding: 0 1em;
    }
    code {
      background: #f8f8f8;
      border: 1px dotted silver;
      padding-left: 0.3em;
      padding-right: 0.3em;
    }
    pre > code {
      display: block;
      overflow: auto;
      padding: 0.5em;
      border: 1px solid #eee;
      line-height: normal;
    }
    .tok-kw {
        color: #333;
        font-weight: bold;
    }
    .tok-str {
        color: #d14;
    }
    .tok-builtin {
        color: #005C7A;
    }
    .tok-comment {
        color: #545454;
        font-style: italic;
    }
    .tok-fn {
        color: #900;
        font-weight: bold;
    }
    .tok-null {
        color: #005C5C;
    }
    .tok-number {
        color: #005C5C;
    }
    .tok-type {
        color: #458;
        font-weight: bold;
    }
    <!-- figure -->
    figure {
      margin: auto 0;
    }
    figure pre {
      margin-top: 0;
    }

    figcaption {
      padding-left: 0.5em;
      font-size: small;
      border-top-left-radius: 5px;
      border-top-right-radius: 5px;
    }
    figcaption.c-cap {
      background: #fcdba5;
    }
    figcaption.peg-cap {
      background: #fcdba5;
    }
    figcaption.javascript-cap {
      background: #365d95;
      color: #fff;
    }
    figcaption.shell-cap {
      background: #ccc;
      color: #000;
    }

</style>
<div id="contents">
<div style="text-align:left; padding up down: 1em">
<h2>C shennanigans.</h2>
</div>
  This text focuses on some of the non-obvious and easy to make mistakes
  non-experienced C programmers are likely to make and are/can not completely
  be covered by tooling without going into edge cases relevant to performance
  and covering the most simple and conservative approach:
  <ol>
    <li><a href="#pointer_semantics">Pointer semantics</a></li>
    <li><a href="#seq_pts">Sequence points</a></li>
    <li><a href="#bitfields">Bit-fields</a></li>
  </ol>
  Compiler flags or implementation may provide workarounds to these problems
  to prevent optimizations based on introduced Undefined Behavior (UB).
  Review used C compilers with flags used including tests and platforms before
  reusing of any code. The
  <a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152200">SEI wiki covers some basic cases</a>
  without covering compiler workarounds.
  Pointer construction is widely unspecified in earlier C standards before
  C11 and up to this day with C23 pointer semantics have no formal model, see also
  item <a href="#pointer_construction_requirements">pointer construction requirements</a>.
<ol>
  <li><a id ="pointer_semantics"><b>Pointer semantics</b> in C</a>.
    <ol>
      <li><a href="#pointer_access_requirements">Pointer access requirements</a></li>
      <li><a href="#pointer_access_practice">Pointer access in practice</a></li>
      <li><a href="#pointer_exceptions">The Exceptions</a></li>
      <li><a href="#pointer_construction_requirements">Pointer construction requirements</a></li>
      <li><a href="#pointer_construction_practice">Pointer construction in practice</a></li>
    </ol>
    <br>
    <ol>
      <li> <a id="pointer_access_requirements"><b>Pointer access requirements</b></a> are fairly well specified from C89 on in
        strong contrast to <a href="#pointer_construction_requirements">pointer construction requirements</a> and programmers with knowledge
        of how processing hardware works can derive below information.
        <ol>
          <li><span>Proper <b>alignment</b></span></li>
            <ul>
              <li><span>Cleanly accessing a pointer with increased alignment requires
                <a href="https://stackoverflow.com/questions/7059299/how-to-properly-convert-an-unsigned-char-array-into-an-uint32-t">to use a temporary with memcopy</a>.</span></li>
              <li><span>To only compare pointers decrease alignment with <code><span class="tok-type">char</span>*</code> pointer.</span></li>
              <li><span>To prune type info for generics use <code>void*</code> pointer.</span></li>
              <li><span>You are responsible to call a function that provides or provide yourself.</span></li>
            </ul>
          <li><span>Sufficient <b>storage</b> (pointer must point to valid object)</span></li>
          <li><span>Sufficient <b>padding</b> (ie withing structs).</span></li>
          <li><span>Correct <b>aliasing</b> (<a id="strict_aliasing_rule"><b>"Strict Aliasing Rule"</b></a>)</span>
            <ul>
<!-- https://gist.github.com/shafik/848ae25ee209f698763cffee272a58f8 -->
              <li><span>C23 6.5 Expressions paragraph 7</span><br>
                "An object shall have its stored value accessed only by an lvalue expression<br>
                that has one of the following types
                &#45; a type compatible with the effective type of the object,<br>
                &#45; a qualified version of a type compatible with the effective type of the object,<br>
                &#45; a type that is the signed or unsigned type corresponding to the effective type of the
                object,<br>
                &#45; a type that is the signed or unsigned type corresponding to a qualified version of the
                effective type of the object,<br>
                &#45; an aggregate or union type that includes one of the aforementioned types among its
                members (including, recursively, a member of a subaggregate or contained union), or<br>
                &#45; a character type."<br>
              </li>
              <li><span>What does this means in <b>practice</b>?</span><br>
                Each pointer has an associated "provenance" it is allowed to point to.
                This mean that a pointer <code>ptr</code> must uphold
                <code>(&amp;array[0] &lt;= ptr &amp;&amp; ptr &lt; &amp;array[len+1]) || ptr != 0)</code>.
                for access with array being the "memory origin range" on stack or heap.
                Pointers must point to the same array, when being used for arithmetic.<br>
                Function arguments of identical pointer types are allowed to have
                overlapping provenance regions, unless annotated with <code><span class="tok-builtin">restrict</span></code>
                (<code><span class="tok-builtin">__restrict__</span></code> for C++ in clang/gcc),
                but pointers of different types are not allowed to have those regions.
                Pointer comparison must be done via identical alignments unless comparison
                of a pointer against pointer to 0 usually
                abbreviated via macro <code><span class="tok-null">NULL</span></code>.<br>
              </li>
            </ul>
          </li>
        </ol>
      </li>
      <li> <a id="pointer_access_practice"><b>Pointer access</b> in <b>practice</b></a>.
        <ul>
          <!-- <span class="tok-kw"></span> -->
          <li><span>Provenance as regions pointer is allowed to point to for access.</span>
      <figure><figcaption class="c-cap"><cite class="file">provenance.c</cite></figcaption>
<pre><code><span class="line"><span class="tok-builtin">#include</span> <span class="tok-str">&lt;stdio.h&gt;</span></span>
<span class="line"><span class="tok-builtin">#include</span> <span class="tok-str">&lt;stdlib.h&gt;</span></span>
<span class="line"><span class="tok-type">void</span> use_ptr(<span class="tok-type">int</span> * arr) {</span>
<span class="line">  printf(<span class="tok-str">"0: %d, 9: %d\n"</span>, arr[0], arr[9]);</span>
<span class="line">}</span>
<span class="line"><span class="tok-type">int</span> main() {</span>
<span class="line">  <span class="tok-type">int</span> arr1[10];</span>
<span class="line">  use_ptr(arr1);</span>
<span class="line">  <span class="tok-type">int</span> * arr2 = malloc(<span class="tok-builtin">sizeof</span>(<span class="tok-type">int</span>));</span>
<span class="line">  use_ptr(arr2);</span>
<span class="line">  free(arr2);</span>
<span class="line">}</span>
</code></pre></figure>
          </li>
          <li><span>Copy around some bytes from not overlapping regions (otherwise use memmove).</span>
      <figure><figcaption class="c-cap"><cite class="file">copy_bytes.c</cite></figcaption>
<pre><code><span class="line"><span class="tok-builtin">#include</span> <span class="tok-str">&lt;string.h&gt;</span></span>
<span class="line"><span class="tok-builtin">#include</span> <span class="tok-str">&lt;stdint.h&gt;</span></span>
<span class="line"><span class="tok-type">void</span> use_bytes(<span class="tok-type">uint8_t</span> * bytes, <span class="tok-type">int32_t</span> len_bytes, <span class="tok-type">uint32_t</span> * output, <span class="tok-type">int32_t</span> len_output) {</span>
<span class="line">  <span class="tok-kw">for</span>(<span class="tok-type">int</span> i=0; i*4&lt;len_bytes &amp;&amp; i&lt;len_output; i+=4) {</span>
<span class="line">    <span class="tok-builtin">memcpy</span>(&amp;output[i], &amp;bytes[4*i], <span class="tok-builtin">sizeof</span>(len_output));
<span class="line">  }</span>
<span class="line">}</span>
</code></pre></figure>
          </li>
          <li><span>Correct alignment of pointers with temporary, when necessary.</span>
      <figure><figcaption class="c-cap"><cite class="file">correct_alignment.c</cite></figcaption>
<pre><code><span class="line"><span class="tok-builtin">#include</span> <span class="tok-str">&lt;string.h&gt;</span></span>
<span class="line"><span class="tok-builtin">#include</span> <span class="tok-str">&lt;stdint.h&gt;</span></span>
<span class="line"><span class="tok-type">int</span> ptr_no_reinterpret_cast() {</span>
<span class="line">  <span class="tok-type">uint8_t</span> arr[4] = {0,0,0,1};</span>
<span class="line">  <span class="tok-comment">// unnecessary variable hopefully elided</span></span>
<span class="line">  <span class="tok-type">uint32_t</span> u32_arr = 0;</span>
<span class="line">  <span class="tok-builtin">memcpy</span>(&amp;u32_arr, &amp;arr[0], 4);</span>
<span class="line">  <span class="tok-type">uint32_t</span> * u32_arr_ptr = &amp;u32_arr;</span>
<span class="line">  <span class="tok-comment">// &lt;use u32_arr_ptr here&gt;</span></span>
<span class="line">  <span class="tok-comment">// Footgun: Dont return stack local variables</span></span>
<span class="line">  <span class="tok-kw">return</span> 0;
<span class="line">}
</code></pre></figure>
          </li>
          <li><span>Ensure correct storage and padding size for pointers via sizeof.</span>
      <figure><figcaption class="c-cap"><cite class="file">storage_padding.c</cite></figcaption>
<pre><code><span class="line"><span class="tok-builtin">#include</span> <span class="tok-str">&lt;stdint.h&gt;</span></span>
<span class="line"><span class="tok-builtin">#include</span> <span class="tok-str">&lt;stdlib.h&gt;</span></span>
<span class="line"><span class="tok-kw">struct</span> sStruct1 {</span>
<span class="line">  <span class="tok-type">uint8_t</span> a1;</span>
<span class="line">  <span class="tok-type">uint8_t</span> a2;</span>
<span class="line">  <span class="tok-type">uint32_t</span> b1;</span>
<span class="line">  <span class="tok-type">uint32_t</span> b2;</span>
<span class="line">};</span>
<span class="line"><span class="tok-type">void</span> padding() {</span>
<span class="line">  <span class="tok-kw">struct</span> sStruct1 * str1 = malloc(<span class="tok-builtin">sizeof</span>(<span class="tok-kw">struct</span> sStruct1)); </span>
<span class="line">  str1-&gt;a1 = 5;</span>
<span class="line">  free(str1);</span>
<span class="line">}</span>
</code></pre></figure>
          </li>
          <li><span>Allowed aliasing of pointers (type-based aliasing analysis)</span>
      <figure><figcaption class="c-cap"><cite class="file">allowed_aliasing.c</cite></figcaption>
<pre><code><span class="line"><span class="tok-builtin">#include</span> <span class="tok-str">&lt;stdint.h&gt;</span></span>
<span class="line"><span class="tok-type">void</span> allowed_aliasing(<span class="tok-type">uint16_t</span> * bytes, <span class="tok-type">int32_t</span> len_bytes, <span class="tok-type">uint16_t</span> * lim) {</span>
<span class="line">  <span class="tok-kw">for</span>(<span class="tok-type">int</span> i=0; i&lt;len_bytes; i+=1) {</span>
<span class="line">    <span class="tok-kw">if</span> (bytes == lim) <span class="tok-type">break</span></span>;
<span class="line">    bytes[i] = 42;</span>
<span class="line">  }</span>
<span class="line">}</span>
</code></pre></figure>
          </li>
          <li><span>Non-allowed aliasing of pointers (type-based aliasing analysis)
      <figure><figcaption class="c-cap"><cite class="file">non_allowed_aliasing.c</cite></figcaption>
<pre><code><span class="line"><span class="tok-type">void</span> non_allowed_aliasing(<span class="tok-type">uint16_t</span> * bytes, <span class="tok-type">int32_t</span> len_bytes, <span class="tok-type">uint8_t</span> * lim) {</span>
<span class="line">  <span class="tok-kw">for</span>(<span class="tok-type">int</span> i=0; i&lt;len_bytes; i+=1) {</span>
<span class="line">    <span class="tok-kw">if</span> (bytes == lim) <span class="tok-type">break</span></span>;
<span class="line">    bytes[i] = 42;</span>
<span class="line">  }</span>
<span class="line">}</span>
</code></pre></figure>
              <!--See example correct_alignment.c</span>-->
          </li>
        </ul>
      </li>
      <li> <a id="pointer_exceptions"><b>The Exceptions</b></a>.
        <ul>
          <li>
            <span>Controlling the build system + compiler invocation to opt-out of provenance based optimizations.</span><br>
            <ol>
              <li><span>Clang and gcc have <code>-fno-strict-aliasing</code>, msvc and tcc do disable type-based aliasing analysis based optimizations.</span></li>
              <li><span>As of 20240603, there is no switch to disable provenance-based alias analysis in compilers (clang, gcc, msvc, tcc).</span></li>
              <li><span>Usage of <code><span class="tok-builtin">restrict</span></code> can be en/disabled in all compilers via <code><span class="tok-builtin">#pragma</span> optimize("", on/off)</code>.</span></li>
              It can also be disabled in all compilers via <code><span class="tok-builtin">#define</span> restrict</code>, using an according optimization level
                (typical -O1) or via separating header and implementation and disabling link time optimziations.</span></li>
            </ol>
          </li>
          <li><span>Posix extension and Windows in practice enable dynamic linking via casting pointers <code>void *</code>to function pointers and back.
              This also means that <code><span class="tok-builtin">sizeof</span> (function pointer) == <span class="tok-builtin">sizeof</span> (<span class="tok-type">void</span> *)</code> must be uphold, which is not true for microcontrollers
              with separate address space for code and data or
              <a href="https://cnlelema.github.io/memo/en/cheri/cheri-c-model/">CHERI in mixed capability mode/hybrid compilation mode</a>.
              Address space annotations are mandatory for this to work and it is unfortunate that standards do not reflect this as of 20240428.
            </span>
      <figure><figcaption class="c-cap"><cite class="file">aliasing_exceptions_uniform_address_space.c</cite></figcaption>
<pre><code><span class="tok-builtin">#include</span> <span class="tok-str">&lt;assert.h&gt;</span>
<span class="tok-builtin">#include</span> <span class="tok-str">&lt;stdint.h&gt;</span>
<span class="tok-type">uint8_t</span> external_memory [1024];
<span class="tok-kw">typedef</span> int(*pfn_add_one)(int);
<span class="tok-type">int</span> add_one(int x) { return x+1; }
<span class="tok-type">void</span> usage(int x) {
  <span class="tok-comment">// read fn ptr from external code</span>
  <span class="tok-type">void</span> * pv_add_one = (<span class="tok-type">void</span>*)external_memory;
  <span class="tok-type">pfn_add_one</span> pfn_add_one_casted = (<span class="tok-type">pfn_add_one</span>)pv_add_one;
  <span class="tok-type">int</span> res = pfn_add_one_casted(1);
  assert(res == 2);
}
</code></pre></figure>
          </li>
        </ul>
      </li>
      <li> <a id="pointer_construction_requirements"><b>Pointer construction requirements</b></a>
        are unspecified in all C standards with potentially some hints and nothing
        concrete up to including C23 which further implies that pointer
        semantics have no formal model.
        At least a few possible formal models exist
        (paper VIP: Verifying Real-World C Idioms with Integer-Pointer Casts,
        N2676, P2318R1: A Provenance-aware Memory Object Model for C) so far without
        taking into account CHERI in mixed capability mode/hybrid compilation mode
        and from what I understand without taking all equivalence classes of
        pointer operations into account.
        <br>
        Therefore it is best to use the most conservative approach xor to provide
        the set of chosen (non-portable) compiler semantics in the build system
        next to the code to remove room for ambiguity.<br>
        For further information about this, take a look into paper "Subtleties of
        the ANSI/ISO C standard" and "n2263: Clarifying Pointer Provenance v4".<br>
        To simplify things, we can however extend the
        <a href="#strict_aliasing_rule">strict aliasing rule</a>
        pointer construction with shortcomings regarding
        "effective type" on type punning for hardware related programming:
        This would mean that generated pointers must uphold
        <code>(&amp;array[0] &lt;= ptr &amp;&amp; ptr &lt;= &amp;array[len+1]) || ptr == 0 || ptr = undefined)</code>
        with <code>ptr == 0</code> and undefined pointers being the exceptions.<br>
<!--In ISO C, it is undefined behaviour to use pointer arithmetic-->
<!--to construct a pointer value that is either below or more than-->
<!--one byte past the footprint of the object [21, 6.5.6p8].-->
<!--SO WG14. Programming languages – C, ISO/IEC 9899:2018 edition, July 2018-->
<!--https://www.cl.cam.ac.uk/~pes20/asplos24spring-paper110.pdf-->
        Standards up to including C23 do not specify this behavior explicitly.
        For example C23 specifies that operations on pointers to a object must
        remain in the above given range and temporal pointer overflow behavior
        is undefined.
        Expected behavior of exposed (externally readable and writable) addresses
        via headers and object files including possible
        future C standard direction can be found in "A Provenance-aware Memory Object Model for C".<br>
        Temporal out of bounds behavior, linker semantics with guaranteed addresses
        or address regions and all other constrains remain unspecified.<br>
        <!--idea double check https://gist.github.com/shafik/848ae25ee209f698763cffee272a58f8-->
        It is not discussed here how the optimizer would prove how serialized and deserialized pointer have the same
        provenance regions (integer cast, memory copy or external usage), because there are multiple algorithms and
        this article is already too long.<br>
        Rust decided to allow programmers experimental low level control over provenance
        with experimenting on CHERI and an interpreter for iterating on the provenance model
        and to work(around) with backends, see
        <a href="https://rust-lang.github.io/rfcs/3559-rust-has-provenance.html#drawbacks">
          Rust RFC 3559 title "rust_has_provenance" and section "Drawbacks"</a>.<br>
        The following special cases of pointer operations can be taken into account, when discussing
        provenance-based optimizations (in contrast to type-based aliasing analysis):
        <ol>
          <li><span><a href="#opaque">Opaque type idiom</a>.</span><br>
            <b>Opaque</b> types provide a way to guarantee correct usage of object and
            pointer properties for a library or API user and thus should be preferred, if feasible.
          </li>
          <li><span><a href="#ptrintconv">Pointer to integer and integer to pointer conversion</a>.</span><br>
            <b>Pointer/integer to integer/pointer conversion</b> mandates in all suggested
            models for pointer semantics (of C) to prevent provenance-based
            optimizations unless the optimizer can prove with certainty the origin
            of pointer provenance <b>and/or</b> programmers must/can annotate
            provenance information to pointers to guide the optimizer about which
            memory relations can and can not be optimized (unstandardised).
          </li>
          <li><span>Headers/exports exposing data structures, pointers to data structures and void pointers.</span><br>
            <a href="#lto"><b>Link time optimization (LTO)</b></a> works across across header and
            object boundaries if sufficient information/artefacts for caller and
            callee are given, so construction of exposed aliasing pointers may lead to
            undefined behavior depending on the build system flags and used compiler.
          </li>
          <li><span>Compiler intrinsics for IO: memcmp, memcpy, memmove, memset.</span><br>
            <a href="#io_intrinsics"><b>IO Compiler intrinsic semantics</b></a> are yet to be taken portably into account
            due to a lot legacy code relying on certain properties and pointer properties
            like alignment being implicit.
            Technically optimizations are possible with annotating sufficient
            pointer information and useful to accelerate via SIMD and tracking
            provenance along pointers, like for different addressing modes or
            capabilities in CHERI, would be further useful.
          </li>
          <li><span>Checking C code validity with Cerberus.</span><br>
            <a href="#cerberus"><b>Cerberus</b></a> allows checking C code semantics for most common idioms,
            but does not support the complete corpus of C syntax.
            It also offers checking semantics of multithreaded code, but this is
            out of scope for this article.
          </li>
          <li><span>CHERI rules for pointers.</span><br>
            In <a href="#cheri"><b>CHERI</b></a> mixed-capability mode pointers may be raw pointers
            inclusive or pointer with annotated capabilities, which can include
            things like lower and upper address bound, permissions masks,
            flags usable for OS or application tasks, see
            "Capability Hardware Enhanced RISC Instructions: CHERI Instruction-Set Architecture (Version 9)".
            Since there is no formal model on how CHERI pointer semantics work, examples are not included.
            A work in progress CHERI C is given in paper "Formal Mechanised Semantics of CHERI C:
            Capabilities, Undefined Behaviour, and Provenance".
            CHERI offers (scalable) compartmentalization, spatial memory safety
            with opt-in temporal memory safety via runtime support mandating
            pointer capability revocation on freeing memory with latest example
            being CheriBSD experimental userspace temporal memory safety (20240602).
          </li>
        </ol>
      <li> <a id="pointer_construction_practice"><b>Pointer construction</b> in <b>practice</b></a>.
        The original intention was to explain provenance based rules, but due to
        long standing bugs in LLVM and gcc and no formal model with performance
        safety, compilation time and other implications, I would suggest the reader
        to write thorough tests and on doubts about testability to disable
        provenance based optimizations, especially in production code.<br>
        Optimizers with provenance based optimization steps are unfortunately
        not build with controllability and debuggability in mind and standard
        bodies so far can not recommend any extensive test corpus to derive
        how frontend and backend optimizer tests would need to be designed.<br>
        Other more elaborative examples can be seen in the github gist
        "What is the Strict Aliasing Rule and Why do we care?".
        <ol>
          <li><span><a id="opaque">Opaque type idiom.<span>
      <figure><figcaption class="c-cap"><cite class="file">opaque.h</cite></figcaption>
<pre><code><span class="line"><span class="tok-builtin">#include</span> <span class="tok-str">&lt;stddef.h&gt;</span></span>
<span class="line"><span class="tok-builtin">#include</span> <span class="tok-str">&lt;stdint.h&gt;</span></span>
<span class="line"><span class="tok-kw">struct</span> item;</span>
<span class="line"><span class="tok-type">size_t</span> item_size(<span class="tok-type">void</span>);
<span class="line"><span class="tok-type">void</span> id_setid(<span class="tok-kw">struct</span> item * it, <span class="tok-type">int32_t</span> id);
<span class="line"><span class="tok-type">int</span> item_getid(<span class="tok-kw">struct</span> item * it);
</code></pre></figure>
      <figure><figcaption class="c-cap"><cite class="file">opaque.c</cite></figcaption>
<pre><code><span class="line"><span class="tok-builtin">#include</span> <span class="tok-str">"opaque.h"</span></span>
<span class="line"><span class="tok-kw">struct</span> item { <span class="tok-type">int32_t</span> id; };
<span class="line"><span class="tok-type">size_t</span> item_size(<span class="tok-type">void</span>) { <span class="tok-kw">return</span> <span class="tok-builtin">sizeof</span>(<span class="tok-kw">struct</span> item); }
<span class="line"><span class="tok-type">void</span> id_setid(<span class="tok-kw">struct</span> item * it, <span class="tok-type">int32_t</span> id) { it-&gt;id = id; }
<span class="line"><span class="tok-type">int</span> item_getid(<span class="tok-kw">struct</span> item * it) { <span class="tok-kw">return</span> it-&gt;id; }
</code></pre></figure>
          </li>
          <li><span><a id="ptrintconv">Pointer to integer and integer to pointer conversion</a>.<span>
      <figure><figcaption class="c-cap"><cite class="file">ptrtoint_inttoptr.c</cite></figcaption>
<pre><code><span class="line"><span class="tok-builtin">#include</span> <span class="tok-str">&lt;assert.h&gt;</span></span>
<span class="line"><span class="tok-builtin">#include</span> <span class="tok-str">&lt;inttypes.h&gt;</span></span>
<span class="line"><span class="tok-builtin">#include</span> <span class="tok-str">&lt;stdio.h&gt;</span></span>
<span class="line"><span class="tok-builtin">#include</span> <span class="tok-str">&lt;stdlib.h&gt;</span></span>
<span class="line"><span class="tok-builtin">#include</span> <span class="tok-str">&lt;string.h&gt;</span></span>
<span class="line"><span class="tok-kw">static</span> <span class="tok-type">void</span> memset_16aligned(<span class="tok-type">void</span> * ptr, <span class="tok-type">char</span> byte, <span class="tok-type">size_t</span> size_bytes, <span class="tok-type">uint16_t</span> alignment) {</span>
<span class="line">    assert((size_bytes &amp; (alignment-1)) == 0); <span class="tok-comment">// Size aligned</span></span>
<span class="line">    assert(((<span class="tok-type">uintptr_t</span>)ptr &amp; (alignment-1)) == 0); <span class="tok-comment">// Pointer aligned</span></span>
<span class="line">    memset(ptr, byte, size_bytes);</span>
<span class="line">}</span>
<span class="line"><span class="tok-comment">// 1. Careful with segmented address spaces: lookup uintptr_t semantics</span></span>
<span class="line"><span class="tok-comment">// 2. Careful with long standing existing optimization compiler bugs pointer to</span></span>
<span class="line"><span class="tok-comment">// integer and back optimizations in for example clang and gcc</span></span>
<span class="line"><span class="tok-comment">// 3. Careful with LTO potentially creating problem 2.</span></span>
<span class="line"><span class="tok-comment">// 4. Consider C11 aligned_alloc or posix_memalign</span></span>
<span class="line"><span class="tok-type">void</span> ptrtointtoptr() {</span>
<span class="line">  const <span class="tok-type">uint16_t</span> alignment = 16;</span>
<span class="line">  const <span class="tok-type">uint16_t</span> align_min_1 = alignment - 1;</span>
<span class="line">  void * mem = malloc(1024+align_min_1);</span>
<span class="line">  <span class="tok-comment">// C89: void *ptr = (void *)(((INT_WITH_PTR_SIZE)mem+align_min_1) &amp; ~(INT_WITH_PTR_SIZE)align_min_1);</span></span>
<span class="line">  <span class="tok-comment">// ie void *ptr = (void *)(((uint64_t)mem+align_min_1) &amp; ~(uint64_t)align_min_1);</span></span>
<span class="line">  <span class="tok-comment">// offset ptr to next alignment byte boundary</span></span>
<span class="line">  <span class="tok-type">void</span> * ptr = (void *)(((uintptr_t)mem+align_min_1) &amp; ~(uintptr_t)align_min_1);</span>
<span class="line">  printf(<span class="tok-str">"0x%08"</span> PRIXPTR <span class="tok-str">", 0x%08"</span> PRIXPTR <span class="tok-str">"\n"</span>, (<span class="tok-type">uintptr_t</span>)mem, (<span class="tok-type">uintptr_t</span>)ptr);</span>
<span class="line">  memset_16aligned(ptr, 0, 1024, alignment);</span>
<span class="line">  free(mem);</span>
<span class="line">}</span>
</code></pre></figure>
          </li>
          <li><span><a id="lto">Link time optimization (LTO) usage and problems</a>.<span>
                One can use <code>ptrtoint_inttoptr.c</code> with flags
                for strong LTO to optimize the bit code of the complete program, for example via
                <code>clang -flto -funified-lto -fuse-ld=lld ptrtoint_inttoptr.c</code>.
          </li>
          <li><span><a id="io_intrinsics">IO Compiler intrinsic semantics example</a>.<span>
                It would be helpful to have a way to add alignment to pointers to
                do runtime selection of the best SIMD routine instead of being forced to do this manually.

      <figure><figcaption class="c-cap"><cite class="file">extern.h</cite></figcaption>
<pre><code><span class="line"><span class="tok-builtin">#include</span> <span class="tok-str"><immintrin.h></span></span>
<span class="tok-type">void</span> memcpy_avx(<span class="tok-type">__m256i</span> * <span class="tok-builtin">__restrict</span> src, <span class="tok-type">__m256i</span> * <span class="tok-builtin">__restrict</span> dest, <span class="tok-type">size_t</span> n);</span>
</code></pre></figure>

      <figure><figcaption class="c-cap"><cite class="file">extern.c</cite></figcaption>
<pre><code><span class="line"><span class="tok-comment"><span class="tok-bultin">#include</span> <span class="tok-str">"extern.h"</span></span></span>
<span class="line"><span class="tok-comment">/// requires 32 byte aligned src, dest; src and dest must not overlap</span></span>
<span class="line"><span class="tok-type">void</span> memcpy_avx(<span class="tok-type">__m256i</span> * <span class="tok-builtin">__restrict</span> src, <span class="tok-type">__m256i</span> * <span class="tok-builtin">__restrict</span> dest, <span class="tok-type">size_t</span> n);</span>
<span class="line">  <span class="tok-type">size_t</span> n_vec = n / <span class="tok-builtin">sizeof</span>(<span class="tok-type">__m256i</span>);</span>
<span class="line">  <span class="tok-kw">for</span>(<span class="tok-type">size_t</span> i=0; i&lt;n_vec; i+=1) {</span>
<span class="line">    const <span class="tok-type">__m256i</span> temp = _mm256_load_si256(src);</span>
<span class="line">    _mm256_store_si256(dest, temp);</span>
<span class="line">    src += 1;</span>
<span class="line">    dest += 1;</span>
<span class="line">  }</span>
<span class="line">}</span>
</code></pre></figure>

      <figure><figcaption class="c-cap"><cite class="file">memcpy_avx.c</cite></figcaption>
<pre><code><span class="tok-builtin">#include</span> <span class="tok-str">&lt;stdio.h&gt;</span>
<span class="tok-builtin">#include</span> <span class="tok-str">&lt;stdint.h&gt;</span></span>
<span class="tok-builtin">#include</span> <span class="tok-str">"extern.h"</span></span>
<span class="tok-type">int</span> main(<span class="tok-type">void</span>) {
  <span class="tok-type">uint8_t</span> mem_src[1024] = { 0 };
  <span class="tok-type">uint8_t</span> mem_dest[1024] = { 0 };
  const <span class="tok-type">uint16_t</span> alignment = 32;
  const <span class="tok-type">uint16_t</span> align_min_1 = alignment - 1;
  <span class="tok-type">__m256i</span> * p_src = (<span class="tok-type">void</span> *)(((<span class="tok-type">uintptr_t</span>)mem_src+align_min_1) &amp; ~(<span class="tok-type">uintptr_t</span>)align_min_1);
  <span class="tok-type">__m256i</span> * p_dest = (<span class="tok-type">void</span> *)(((<span class="tok-type">uintptr_t</span>)mem_dest+align_min_1) &amp; ~(<span class="tok-type">uintptr_t</span>)align_min_1);
  memcpy_avx(p_src, p_dest, 4);
  fprintf(stdout, <span class="tok-str">"p_src: %p, p_dest: %p\n"</span>, (<span class="tok-type">void</span>*)p_src, (<span class="tok-type">void</span>*)p_dest);
  <span class="tok-kw">return</span> 0;
}
<span class="tok-comment">// clang -Weverything -O3 -march=native memcpy_avx.c extern.c &amp;&amp; ./a.out</span>
<span class="tok-comment">// Output (contains C++ warnings):</span>
<span class="tok-comment">// extern.c:8:5: warning: unsafe pointer arithmetic [-Wunsafe-buffer-usage]</span>
<span class="tok-comment">//     8 |     src += 1;</span>
<span class="tok-comment">//       |     ^~~</span>
<span class="tok-comment">// extern.c:9:5: warning: unsafe pointer arithmetic [-Wunsafe-buffer-usage]</span>
<span class="tok-comment">//     9 |     dest += 1;</span>
<span class="tok-comment">//       |     ^~~~</span>
<span class="tok-comment">// 2 warnings generated.</span>
<span class="tok-comment">// p_src: 0x7ffceb985a60, p_dest: 0x7ffceb985660</span>
</code></pre></figure>
          </li>
          <li><span><a id="cerberus">Checking C code validity with Cerberus</a> does not imply absence of compiler miscompilations.<span>
      <figure><figcaption class="c-cap"><cite class="file">cerberus_install.sh</cite></figcaption>
<pre><code><span class="line"><span class="tok-comment"># Install opam with ocaml</span></span>
<span class="line">git clone https://github.com/rems-project/cerberus</span>
<span class="line">opam install --deps-only ./cerberus-lib.opam ./cerberus.opam</span>
<span class="line">make</span>
<span class="line">make install DESTDIR=$HOME/.local/cerberus</span>
<span class="line">echo 'PATH=${PATH}:"$HOME/.local/cerberus/bin"' &gt;&gt; ~/.bashrc</span>
<span class="line">eval (opam env)</span>
<span class="line">cerberus --help</span>
</code></pre></figure>

      <figure><figcaption class="c-cap"><cite class="file">extern.h</cite></figcaption>
<pre><code><span class="line"><span class="tok-builtin">#include</span> <span class="tok-str">&lt;stddef.h&gt;</span></span>
<span class="line"><span class="tok-kw">extern</span> <span class="tok-type">size_t</span> x;</span>
</code></pre></figure>

      <figure><figcaption class="c-cap"><cite class="file">extern.c</cite></figcaption>
<pre><code><span class="tok-builtin">#include</span> <span class="tok-str">"extern.h"</span></span>
<span class="line"><span class="tok-type">size_t</span> x = 0;</span>
</code></pre></figure>

      <figure><figcaption class="c-cap"><cite class="file">ptr_provenance_miscompilation.c</cite></figcaption>
<pre><code><span class="line"><span class="tok-builtin">#include</span> <span class="tok-str">&lt;stddef.h&gt;</span></span>
<span class="line"><span class="tok-builtin">#include</span> <span class="tok-str">&lt;stdio.h&gt;</span></span></span>
<span class="line"><span class="tok-builtin">#include</span> <span class="tok-str">"extern.h"</span></span></span>
<span class="line"><span class="tok-comment">// Removing restrict makes the miscompilation go away</span></span>
<span class="line"><span class="tok-type">size_t</span> f(<span class="tok-type">size_t</span> * <span class="tok-kw">restrict</span> ptr_to_x);</span>
<span class="line"><span class="tok-type">size_t</span> f(<span class="tok-type">size_t</span> * <span class="tok-kw">restrict</span> ptr_to_x) {</span>
<span class="line">  <span class="tok-type">size_t</span> * p = ptr_to_x;</span>
<span class="line">  *p = 1;</span>
<span class="line">  <span class="tok-kw">if</span> (p == &amp;x) {</span>
<span class="line">      <span class="tok-comment">// Expected branch, taken only in Debug mode</span></span>
<span class="line">      *p = 2;</span>
<span class="line">  }</span>
<span class="line">  <span class="tok-kw">return</span> *p;</span>
<span class="line">}</span>
<span class="line"><span class="tok-type">int</span> main(<span class="tok-type">void</span>) {</span>
<span class="line">  <span class="tok-kw">if</span> (f(&amp;x) == 1) fprintf(stderr, <span class="tok-str">"panic : p != &amp;x\n"</span>);</span>
<span class="line">}</span>
<span class="line"><span class="tok-comment">// clang -O0 -Weverything ptr_provenance_miscompilation.c extern.c &amp;&amp; ./a.out</span></span>
<span class="line"><span class="tok-comment">// output:</span></span>
<span class="line"><span class="tok-comment">// clang -O1 -Weverything ptr_provenance_miscompilation.c extern.c &amp;&amp; ./a.out</span></span>
<span class="line"><span class="tok-comment">// output: panic : p != &amp;x</span></span>
<span class="line"><span class="tok-comment">// cerberus ptr_provenance_miscompilation.c extern.c</span></span>
<span class="line"><span class="tok-comment">// output:</span></span>
<span class="line"><span class="tok-comment">// merging everything into ptr_provenance_miscompilation.c</span></span>
<span class="line"><span class="tok-comment">// cerberus ptr_provenance_miscompilation.c</span></span>
<span class="line"><span class="tok-comment">// output:</span></span>
</code></pre></figure>
          </li>
          <li><span><a id="cheri">CHERI usage if left as task for the reader.</a>.<span>
                Useful links are <code>https://github.com/CTSRD-CHERI/cheribuild</code> and
                <code>https://github.com/CTSRD-CHERI/cheri-c-programming</code> and
                <code>https://github.com/capablevms/cheri-examples</code>.
          </li>
        </ol>
      </li>
    </ol>
  <li> <a id="seq_pts"><b>Sequence Points</b></a> in simple case and with storage lifetime extension.
  <figure><figcaption class="c-cap"><cite class="file">sequence_points.c</cite></figcaption>
<pre><code><span class="line"><span class="tok-builtin">#include</span> <span class="tok-str">&lt;stdint.h&gt;</span></span>
<span class="line"><span class="tok-builtin">#include</span> <span class="tok-str">&lt;stdio.h&gt;</span></span>
<span class="line"><span class="tok-type">int</span> f(<span class="tok-type">int</span>* a) {</span>
<span class="line">  *a=*a+1;</span>
<span class="line">  return *a;</span>
<span class="line">}</span>
<span class="line"><span class="tok-type">void</span> simple_sequence_points() {</span>
<span class="line">  <span class="tok-type">int</span> a = 0;</span>
<span class="line">  <span class="tok-comment">// warning: Multiple unsequenced modifications to a</span></span>
<span class="line">  <span class="tok-comment">// a = a++ + a++;</span></span>
<span class="line">  <span class="tok-comment">// Problem without warnings</span></span>
<span class="line">  <span class="tok-comment">a = f(&amp;a) + f(&amp;a);</span></span>
<span class="line">  a = f(&amp;a);</span>
<span class="line">  a += f(&amp;a);</span>
<span class="line">}</span>
<span class="line"><span class="tok-type">struct</span> sExample { <span class="tok-type">int32_t</span> a[1]; };</span>
<span class="line"><span class="tok-type">struct</span> sExample create_sExample(void) {</span>
<span class="line">  <span class="tok-type">struct</span>t sExample res = { { 1 } };</span>
<span class="line">  <span class="tok-kw">return</span> res;</span>
<span class="line">}</span>
<span class="line"><span class="tok-type">int</span> storage_lifetime_footgun(void) {</span>
<span class="line">  <span class="tok-comment">// undefined behavior introduced if temporary is missing</span>
<span class="line">  <span class="tok-comment">// printf("%x", ++(create_fail().a[0]));</span></span>
<span class="line">  <span class="tok-type">struct</span> sExample res = create_sExample();</span>
<span class="line">  printf("%x", ++(res.a[0]));</span>
<span class="line">  return 0;</span>
<span class="line">}</span>
</code></pre></figure>
  </li>
  <li> <a id="bitfields"><b>Bit-fields</b></a> should not be used unless for non-portable code regarding compilers
    and CPUs and do not make assumptions regarding the layout of structures
    with bit-fields and use <code>static_assert/_Static_assert</code> on every struct.
    Keep bit-fields as simple as possible, meaning prefer not to nest them or also
    <code>static_assert</code> the layout.<br>
    <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf">Reasons from ISO/IEC 9899:TC3</a><br>
    &gt;  An implementation may allocate any addressable storage unit large enough to hold a bit<br>
    &gt;  field. If enough space remains, a bit-field that immediately follows another bit-field in a<br>
    &gt;  structure shall be packed into adjacent bits of the same unit. If insufficient space remains,<br>
    &gt;  whether a bit-field that does not fit is put into the next unit or overlaps adjacent units is<br>
    &gt;  implementation-defined. The order of allocation of bit-fields within a unit (high-order to<br>
    &gt;  low-order or low-order to high-order) is implementation-defined. The alignment of the<br>
    &gt;  addressable storage unit is unspecified.<br>
    or in other words:
    <ol>
      <li>Order of allocation not specified.</li>
      <li>Most significant bit not specified.</li>
      <li>Alignment is not specified.</li>
      <li>Implementations can determine, whether bit-fields cross a storage unit boundary.</li>
      <li>Structs may contain padding bytes anywhere.</li>
    </ol>
  </li>
</ol>
</div>
</html>