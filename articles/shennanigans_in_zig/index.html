<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Jans Website</title>
    <link rel="stylesheet" type="text/css" href="/normalize.css">
    <link rel="stylesheet" type="text/css" href="/style.css">
  </head>
  <body>
    <div class="home_page">
      <div class='static_grid'>
          <div class='static_double_column1'>
            <h1><span class="reset_a"><a href="/">Jans Website</a></span></h1>
          </div>
          <div class='static_double_column2'>
            <h2>Zig shennanigans.</h2>
          </div>
          <div class='static_double_column3'>
            <div><div id=intro><p> As of <del>20240404 (zig version 0.12.0-dev.3562+96bc8f17c)</del> 20240701 (zig version 0.14.0-dev.4234+1e3fb4825),</p><ul><li>Zig provides one of the best possible semantics to optimize memory details, while offering widely portable source code with reasonable safety in a relative concise and readable way.</li><li>Aside of signaling for toolings, I found personally no major annoying parts. For example, picking up nested slices and some build system parts might be inconvenient, but those are one time things and no footguns.</li></ul><p>The rest of the language feels very smooth to me in contrast to the potential very flexible and cryptic syntax of C (see <a href="https://github.com/JadLevesque/PPMP-Iceberg" target="_blank">preprocessor iceberg</a>).</p><ul><li>Bottlenecks of array assignments not obvious via <code>@memcpy</code>: <figure><pre><code class="zig"><span class="keyword">test</span> <span class="string">&quot;perf array assignment&quot;</span> <span class="punctuation bracket">{</span>
    <span class="type qualifier">const</span> <span class="variable">x</span><span class="punctuation delimiter">:</span> <span class="type builtin">u8</span> = <span class="number">100</span><span class="punctuation delimiter">;</span>
    <span class="type qualifier">const</span> <span class="variable">a</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="number">1_000_000</span><span class="punctuation bracket">]</span><span class="type builtin">u8</span> = <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">x</span><span class="punctuation bracket">}</span> <span class="operator">**</span> <span class="number">1_000_000</span><span class="punctuation delimiter">;</span>
    <span class="type qualifier">var</span> <span class="variable">b</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="number">1_000_000</span><span class="punctuation bracket">]</span><span class="type builtin">u8</span> = <span class="constant builtin">undefined</span><span class="punctuation delimiter">;</span>
    <span class="comment">// pile of code</span>

    <span class="variable">b</span> <span class="operator">=</span> <span class="variable">a</span><span class="punctuation delimiter">;</span> <span class="comment">// spot the performance issue</span>

    <span class="comment">// pile of code</span>
<span class="punctuation bracket">}</span>
</code></pre>
<figcaption>perf_array_assignment.zig</figcaption></figure></li><li>Signaling: Test runner allows no signaling to <code>qemu -g 4242</code> (debugger mode). Qemu uses gdb server signaling, which means sending SIGKILL is necessary to kill the debugging server process.</li><li>Memory, aliasing and pointer semantics: Zig inherits from LLVM potential miscompilations due to longstanding provenance and aliasing bugs. (Updated 20240701)<ul><li><a href="https://github.com/ziglang/zig/issues/20198" target="_blank">Zig upstream issue</a></li><li><a href="https://github.com/llvm/llvm-project/issues/33896" target="_blank">LLVM upstream issue</a></li><li><a href="https://rust-lang.github.io/rfcs/3559-rust-has-provenance.html" target="_blank">Related Rust RFC</a></li><li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=105294#c2" target="_blank">Related gcc issue</a></li></ul></li><li>Weak memory semantics: Zig inherits from LLVM the same class of problems from the C11 memory model. As of 20240701, and take below statements with a big grain of salt, since I did not check thoroughly common vendors and I do mostly rely on talks from ACM SIGPLAN FOWM’24 and “Multicore Semantics: Making Sense of Relaxed Memory”. (Updated 20240701)<ul><li>There is nothing conclusive on how the “out of thin air problem” should be fixed, which is problematic for reasoning with weak memory.</li><li>Many hardware architectures have no sufficiently ISA-complete (and formally verified) synchronization models.</li><li>There is no official test corpus to stress test architectures by vendors or third parties.</li><li>There is no official test corpus with code and optimization models to test formal model influence of example code.</li><li>There is no debugging tooling to identify and trace or track down synchronization bugs from weak memory (in production) or vendor recommended strategies to stress test on their platforms (derived from the formal models of the architecture).</li></ul></li></ul></div></div>
          </div>
      </div>
    </div>
  </body>
</html>
