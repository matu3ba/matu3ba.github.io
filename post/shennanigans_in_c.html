<!doctype html>
<html lang="en"><meta charset=utf-8>
<title>C shennanigans.</title>
<style>
    #contents {
      max-width: 60em;
      margin: auto;
      padding: 0 1em;
    }
    code {
      background: #f8f8f8;
      border: 1px dotted silver;
      padding-left: 0.3em;
      padding-right: 0.3em;
    }
    pre > code {
      display: block;
      overflow: auto;
      padding: 0.5em;
      border: 1px solid #eee;
      line-height: normal;
    }
    .tok-kw {
        color: #333;
        font-weight: bold;
    }
    .tok-str {
        color: #d14;
    }
    .tok-builtin {
        color: #005C7A;
    }
    .tok-comment {
        color: #545454;
        font-style: italic;
    }
    .tok-fn {
        color: #900;
        font-weight: bold;
    }
    .tok-null {
        color: #005C5C;
    }
    .tok-number {
        color: #005C5C;
    }
    .tok-type {
        color: #458;
        font-weight: bold;
    }
    <!-- figure -->
    figure {
      margin: auto 0;
    }
    figure pre {
      margin-top: 0;
    }

    figcaption {
      padding-left: 0.5em;
      font-size: small;
      border-top-left-radius: 5px;
      border-top-right-radius: 5px;
    }
    figcaption.c-cap {
      background: #fcdba5;
    }
    figcaption.peg-cap {
      background: #fcdba5;
    }
    figcaption.javascript-cap {
      background: #365d95;
      color: #fff;
    }
    figcaption.shell-cap {
      background: #ccc;
      color: #000;
    }

</style>
<div id="contents">
<div style="text-align:left; padding up down: 1em">
<h2>C shennanigans.</h2>
</div>
  This text focuses on some of the non-obvious and easy to make mistakes
  non-experienced C programmers are likely to make and are/can not completely
  be covered by tooling without going into edge cases relevant to performance:
  <ol>
    <li><a href="#pointer_semantics">Pointer semantics</a></li>
    <li><a href="#seq_pts">Sequence points</a></li>
    <li><a href="#bitfields">Bit-fields</a></li>
  </ol>
  Compiler flags or implementation may provide workarounds to these problems
  to prevent optimizations based on introduced Unedefined Behavior (UB).
  Review used C compilers with flags used including tests and and platforms before
  reusing of any code. The
  <a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152200">SEI wiki covers some basic cases</a>
  without covering compiler workarounds.
  Pointer construction is widely unspecified in earlier C standards before
  C11 and up to this day with C23 pointer semantics have no formal model, see also
  item <a href="#pointer_construction">pointer construction</a>.
<ol>
  <li><a id ="pointer_semantics"><b>Pointer semantics</b> in C</a>.
    <ol>
      <li><a href="#pointer_access_requirements">Pointer access requirements</a></li>
      <li><a href="#pointer_access_practice">Pointer access in practice</a></li>
      <li><a href="#pointer_exceptions">The Exceptions</a></li>
      <li><a href="#pointer_construction_reqirements">Pointer construction requirements</a></li>
      <li><a href="#pointer_construction_practice">Pointer construction in practice</a></li>
    </ol>
    <br>
    <ol>
      <li> <a id="pointer_access_requirements"><b>Pointer access requirements</b></a> are fairly well specified from C89 on in
        strong contrast to pointer construction and programmers with knowledge
        of how processing hardware works can derive below information.
        <ol>
          <li><span>Proper alignment</span></li>
            <ul>
              <li><span>Cleanly accessing a pointer with increased alignment requires
                <a href="https://stackoverflow.com/questions/7059299/how-to-properly-convert-an-unsigned-char-array-into-an-uint32-t">to use a temporary with memcopy</a>.</span></li>
              <li><span>To only compare pointers decrease alignment with <code>char*</code> pointer.</span></li>
              <li><span>To prune type info for generics use <code>void*</code> pointer.</span></li>
              <li><span>You are responsible to call a function that provides or provide yourself.</span></li>
            </ul>
          <li><span>Sufficient storage (pointer must point to valid object)</span></li>
          <li><span>Sufficient padding (ie withing structs).</span></li>
          <li><span>Correct aliasing</span>
            <ul>
              <li>"Strict Aliasing Rule"<br>
                &gt; Dereferencing a pointer that aliases an object that is not of a<br>
                &gt; compatible type or one of the other types allowed by<br>
                &gt; C 2011 6.5 paragraph 71 is undefined behavior.<br>
                What this means in practice:<br>
                Each pointer has an associated "provenance" it is allowed to point to.
                This mean that a pointer <code>ptr</code> must uphold
                <code>(&amp;array[0] &lt;= ptr &amp;&amp; ptr &lt; &amp;array[len+1]) || ptr != 0)</code>.
                for access with array being the "memory origin range" on stack or heap.
                Pointers must point ot the same array, when being used for arithmetic.<br>
                Function arguments of identical pointer types are allowed to have
                overlapping provenance regions, unless annotated with <code>__restrict__</code>,
                but pointers of different types are not allowed to have those regions.
                Pointer comparison must be done via identical alignments, for
                example to compare a pointer against pointer to 0 (usually
                abbreviated via maro <code>NULL</code>).<br>
              </li>
            </ul>
          </li>
          <li>TODO double check if this is sufficient.</li>
        </ol>
      </li>
      <li> <a id="pointer_access_practice"><b>Pointer access</b> in <b>practice</b></a>.
        <ul>
          <!-- <span class="tok-kw"></span> -->
          <li><span>Provenance as regions pointer is allowed to point to for access.</span>
      <figure><figcaption class="c-cap"><cite class="file">provenance.c</cite></figcaption>
<pre><code><span class="line"><span class="tok-type">void</span> use_ptr(<span class="tok-kw">int</span> * ptr) {</span>
<span class="line">  <span class="tok-kw">printf</span>("0: %d, 9: %d\n", arr[0], arr[9]);</span>
<span class="line">}</span>
<span class="line"><span class="tok-type">void</span> main() {</span>
<span class="line">  <span class="tok-type">int</span> arr1[10]</span>
<span class="line">  use_ptr(arr1);</span>
<span class="line">  <span class="tok-type">int</span> * arr2 = <span class="tok-kw">malloc</span>(<span class="tok-kw">sizeof</span>(int));</span>
<span class="line">  use_ptr(arr2);</span>
<span class="line">  <span class="tok-kw">free</span>(arr2);</span>
<span class="line">}</span>
</code></pre></figure>
          </li>
          <li><span>Copy around some bytes from not overlapping regions (otherwise use memmove).</span>
      <figure><figcaption class="c-cap"><cite class="file">copy_bytes.c</cite></figcaption>
<pre><code><span class="line"><span class="tok-type">void</span> use_bytes(uint8_t * bytes, int32_t len_bytes, uint32_t * output, int32_t len_output) {</span>
<span class="line">  <span class="tok-kw">for</span>(<span class="tok-type">int</span> i=0; i*4&lt;len_bytes &amp;&amp; i&lt;len_output; i+=4) {</span>
<span class="line">    <span class="tok-kw">memcpy</span>(&amp;output[i], &amp;bytes[4*i], <span class="tok-kw">sizeof</span>(len_output));
<span class="line">  }</span>
<span class="line">}</span>
</code></pre></figure>
          </li>
          <li><span>Correct alignment of pointers with temporary, when necessary.</span>
      <figure><figcaption class="c-cap"><cite class="file">correct_alignment.c</cite></figcaption>
<pre><code><span class="line"><span class="tok-type">int</span> ptr_no_reinterpret_cast() {</span>
<span class="line">  <span class="tok-type">uint8_t</span> arr[4] = {0,0,0,1};</span>
<span class="line">  <span class="tok-comment">// unnecessary variable hopefully elided</span></span>
<span class="line">  <span class="tok-type">uint32_t</span> u32_arr = 0;</span>
<span class="line">  <span class="tok-kw">memcpy</span>(&amp;u32_arr, &amp;arr[0], 4);</span>
<span class="line">  <span class="tok-type">uint32_t</span> * u32_arr_ptr = &amp;u32_arr;</span>
<span class="line">  <span class="tok-comment">// &lt;use u32_arr_ptr here&gt;</span></span>
<span class="line">  <span class="tok-comment">// Footgun: Dont return stack local variables</span></span>
<span class="line">  <span class="tok-kw">return</span> 0;
<span class="line">}
</code></pre></figure>
          </li>
          <li><span>Ensure correct storage and padding size for pointers via sizeof.</span>
      <figure><figcaption class="c-cap"><cite class="file">storage_padding.c</cite></figcaption>
<pre><code><span class="line"><span class="tok-type">struct</span> sStruct1 {</span>
<span class="line">  uint8_t a1;</span>
<span class="line">  uint8_t a2;</span>
<span class="line">  uint32 b1;</span>
<span class="line">  uint32 b2;</span>
<span class="line">}</span>
<span class="line"><span class="tok-type">void</span> padding() {</span>
<span class="line">  <span class="tok-kw">struct</span> sStruct1 * str1 = <span class="tok-kw">malloc</span>(<span class="tok-kw">sizeof</span>(sStruct1)); </span>
<span class="line">  str1.a1 = 5;</span>
<span class="line">  <span class="tok-kw">free</span>(str1);</span>
<span class="line">}</span>
</code></pre></figure>
          </li>
          <li><span>Allowed aliasing of pointers</span>
      <figure><figcaption class="c-cap"><cite class="file">allowed_aliasing.c</cite></figcaption>
<pre><code><span class="line"><span class="tok-type">void</span> allowed_aliasing(uint16_t * bytes, int32_t len_bytes, uint16_t * lim) {</span>
<span class="line">  <span class="tok-kw">for</span>(<span class="tok-type">int</span> i=0; i&lt;len_bytes; i+=1) {</span>
<span class="line">    <span class="tok-kw">if</span> (bytes == lim) break</span>;
<span class="line">    bytes[i] = 42;</span>
<span class="line">  }</span>
<span class="line">}</span>
</code></pre></figure>
          </li>
          <li><span>Non-Allowed aliasing of pointers: See example correct_alignment.c</span></li>
        </ul>
      </li>
      <li> <a id="pointer_exceptions"><b>The Exceptions</b></a>.
        <ul>
          <li>
            <span>Controlling the build system + compiler invocation to opt-out.</span><br>
            <ol>
              <li><span>Clang and gcc have <code>-fno-strict-aliasing</code>, msvc and tcc do not implement strict aliasing based optimizations.</span></li>
              <li><span>Usage of <code>restrict</code> can be en/disabled in all compilers via <code>#pragma optimize("", on/off)</code>.</span></li>
              It can also be disabled in all compilers via <code>#define restrict</code>, using an according optimization level
                (typical -O1) or via separating header and implementation and disabling link time optimziations.</span></li>
            </ol>
          </li>
          <li><span>Posix extension and Windows in practice enable dynamic linking via casting pointers <code>void *</code>to function pointers and back.
              This also means that <code>sizeof (function pointer) == sizeof (void *)</code> must be uphold, which is not true for microcontrollers
              with separate address space for code and data or
              <a href="https://cnlelema.github.io/memo/en/cheri/cheri-c-model/">CHERI in mixed capability mode/hybrid compilation mode</a>.
              Address space annotations are mandatory for this to work and it is unfortunate that standards do not reflect this as of 20240428.
            </span>
      <figure><figcaption class="c-cap"><cite class="file">aliasing_exceptions_uniform_address_space.c</cite></figcaption>
<pre><code><span class="line"><span class="tok-type">void</span> aliasing_exceptions_uniform_address_space() {</span>
<span class="line">  <span class="tok-kw">typedef</span> <span class="tok-type">int</span>(*pfn_add_one)(<span class="tok-type">int</span>);</span>
<span class="line">  <span class="tok-type">int</span> add_one(<span class="tok-type">int</span> x) = { return x+1; } </span>
<span class="line">  <span class="tok-type">void</span> usage(<span class="tok-type">int</span> x) {</span>
<span class="line">    // read fn ptr from external code
<span class="line">    <span class="tok-type">void</span> * pv_add_one = (void*)external_memory;</span>
<span class="line">    <span class="tok-kw">pfn_add_one</span> pfn_add_one_casted = (pfn_add_one)pv_add_one;</span>
<span class="line">    <span class="tok-kw">int</span> res = pfn_add_one_casted(1);</span>
<span class="line">    assert(res == 1);</span>
<span class="line">  }</span>
<span class="line">}</span>
</code></pre></figure>
          </li>
        </ul>
      </li>
      <li> <a id="pointer_construction_reqirements"><b>Pointer construction requirements</b></a>
        are widely unspecified in earlier C standards before
        C11 and up to this day with C23 pointer semantics have no formal model,
        but at least a few possible formal models exist
        (paper VIP: Verifying Real-World C Idioms with Integer-Pointer Casts,
        N2676, P2318R1: A Provenance-aware Memory Object Model for C) so far without
        taking into account CHERI in mixed capability mode/hybrid compilation mode
        and from what I understand without taking all equivalence classes of
        pointer operations into account.<br>
        Therefore it is best to use the most conservative approach xor to provide
        the set of chosen (non-portable) compiler semantics in the build system
        next to the code to remove room for ambiguity.<br>
        For further information about this, take a look into paper "Subtleties of
        the ANSI/ISO C standard" and "n2263: Clarifying Pointer Provenance v4".<br>
        Generally, the following cases of pointer creation disable pointer based optimizations
        unless the optimizer can prove sufficient properties are uphold for the special cases:
        <ol>
          <li><a href="#ptrintconv">Pointer to integer and integer to pointer conversion</a>.</li>
          <li><a href="#opaque">Opaque type and pointer conversion with usage</a>.</li>
          <li><a href="#headers">Headers/exports exposing data structures, pointers to data structures and void pointers</a>.</li>
          <li><a href="#intrinsics">Compiler intrinsics for IO: memcpy, memset, memmove, [m,c]alloc</a>.</li>
          <li>TODO double check if this is sufficient.</li>
        </ol>
        Besides that, LTO and more aggressive optimizations without overhead of
        pointer escape analysis mandate that each created pointer must remain
        within the provenance region sketched in LINK.

      <li> <a id="pointer_construction_practice"><b>Pointer construction</b> in <b>practice</b></a>.
        <ol>
          <li><span><a id="ptrintconv">Pointer to integer and integer to pointer conversion</a>.<span>
                TODO
          </li>
          <li><span><a id="opaque">Opaque type and pointer conversion with usage.<span>
                TODO
          </li>
          <li><span><a id="headers">Headers/exports exposing data structures, pointers to data structures and void pointers</a><span>
                TODO
          </li>
          <li><span><a id="intrinsics">Compiler intrinsics for IO: memcpy, memset, memmove, [m,c]alloc</a>.<span>
                TODO
          </li>
          <!-- I'd be very curious about weird embedded compiler semantics in C89 and C99 due -->
          <!-- to reading paper "Subtleties of the ANSI/ISO C standard". -->
          <!-- https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1637.pdf and how much stuff -->
          <!-- https://www.cl.cam.ac.uk/~pes20/cerberus/clarifying-provenance-v4.html#q3.-can-one-make-a-usable-pointer-via-casts-to-intptr_t-and-back -->
          <!-- https://cs61.seas.harvard.edu/site/2018/Datarep4/ -->
        </ol>
      </li>
    </ol>
  <li> <a id="seq_pts"><b>Sequence Points</b></a> in simple case and with storage lifetime extension.
  <figure><figcaption class="c-cap"><cite class="file">sequence_points.c</cite></figcaption>
<pre><code><span class="line"><span class="tok-type">int</span> f(<span class="tok-type">int</span>* a) {</span>
<span class="line">  *a=*a+1;</span>
<span class="line">  return *a;</span>
<span class="line">}</span>
<span class="line"><span class="tok-type">void</span> simple_sequence_points() {</span>
<span class="line">  <span class="tok-type">int</span> a = 0;</span>
<span class="line">  <span class="tok-comment">// warning: Multiple unsequenced modifications to a</span></span>
<span class="line">  <span class="tok-comment">// a = a++ + a++;</span></span>
<span class="line">  <span class="tok-comment">// Problem without warnings</span></span>
<span class="line">  <span class="tok-comment">a = f(&amp;a) + f(&amp;a);</span></span>
<span class="line">  a = f(&amp;a);</span>
<span class="line">  a += f(&amp;a);</span>
<span class="line">}</span>
<span class="line"><span class="tok-type">struct</span> sExample { <span class="tok-type">int32_t</span> a[1]; };</span>
<span class="line"><span class="tok-type">struct</span> sExample create_sExample(void) {</span>
<span class="line">  <span class="tok-type">struct</span>t X res = { { 1 } };</span>
<span class="line">  <span class="tok-kw">return</span> res;</span>
<span class="line">}</span>
<span class="line"><span class="tok-type">int</span> storage_lifetime_footgun(void) {</span>
<span class="line">  <span class="tok-comment">// undefined behavior introduced if temporary is missing</span>
<span class="line">  <span class="tok-comment">// printf("%x", ++(create_fail().a[0]));</span></span>
<span class="line">  <span class="tok-type">struct</span> sExample res = create_sExample();</span>
<span class="line">  <span class="tok-kw">printf</span>("%x", ++(res.a[0]));</span>
<span class="line">  return 0;</span>
<span class="line">}</span>
</code></pre></figure>
  </li>
  <li> <a id="bitfields"><b>Bit-fields</b></a> should not be used unless for non-portable code regarding compilers
    and CPUs and do not make assumptions regarding the layout of structures
    with bit-fields and use <code>static_assert/_Static_assert</code> on every struct.
    Keep bit-fields as simple as possible, meaning prefer not to nest them or also
    <code>static_assert</code> the layout.<br>
    <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf">Reasons from ISO/IEC 9899:TC3</a><br>
    &gt;  An implementation may allocate any addressable storage unit large enough to hold a bit<br>
    &gt;  field. If enough space remains, a bit-field that immediately follows another bit-field in a<br>
    &gt;  structure shall be packed into adjacent bits of the same unit. If insufficient space remains,<br>
    &gt;  whether a bit-field that does not fit is put into the next unit or overlaps adjacent units is<br>
    &gt;  implementation-defined. The order of allocation of bit-fields within a unit (high-order to<br>
    &gt;  low-order or low-order to high-order) is implementation-defined. The alignment of the<br>
    &gt;  addressable storage unit is unspecified.<br>
    or in other words:
    <ol>
      <li>Order of allocation not specified.</li>
      <li>Most significant bit not specified.</li>
      <li>Alignment is not specified.</li>
      <li>Implementations can determine, whether bit-fields cross a storage unit boundary.</li>
      <li>Structs may contain padding bytes anywhere.</li>
    </ol>
  </li>
</ol>
</div>
</html>